#+begin_export latex
The program \ty{never} is a webserver that provides access to a REST
API to the facilities of the Neighbors package; hence the name
\emph{Neighbors Sever}, or \ty{never}.

Our outline of \ty{never} contains hooks for imports, types, methods,
functions, and the logic of the main function.\bpr{never}{pr:nev}
#+end_export
#+begin_src go <<never.go>>=
  package main

  import (
	  //<<Imports, Pr. \ref{pr:nev}>>
  )

  //<<Types, Pr. \ref{pr:nev}>>
  //<<Methods, Pr. \ref{pr:nev}>>
  //<<Functions, Pr. \ref{pr:nev}>>
  func main() {
	  //<<Main function, Pr. \ref{pr:nev}>>
  }
#+end_src
#+begin_export latex
\epr In the main function we prepare logging, before we construct and
start the server.
#+end_export
#+begin_src go <<Main function, Pr. \ref{pr:nev}>>=
  util.PrepLog("never")
  //<<Construct server, Pr. \ref{pr:nev}>>
  //<<Start server, Pr. \ref{pr:nev}>>
#+end_src
#+begin_export latex
We import \ty{util}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:nev}>>=
  "github.com/evolbioinf/never/util"
#+end_src
#+begin_export latex
Our web server, like any web server, consists of two parts, a front
end and a back end. The front end consists of the things seen by the
user via a browser. This often consists of web pages, but may be as
light weight as a URL extended by a query.

The back end consists of a command-line program seen by the sysadmin
who starts the server. The back end is simpler than the front end, so
we start with it.
#+end_export
#+begin_src go <<Construct server, Pr. \ref{pr:nev}>>=
  //<<Construct back end, Pr. \ref{pr:nev}>>
  //<<Construct front end, Pr. \ref{pr:nev}>>
#+end_src
#+begin_export latex
  \section{Back End}
  In the back end we declare the flags, set the usage, parse the
  flags, and respond to them.
#+end_export
#+begin_src go <<Construct back end, Pr. \ref{pr:nev}>>=
  //<<Declare flags, Pr. \ref{pr:nev}>>
  //<<Set usage, Pr. \ref{pr:nev}>>
  flag.Parse()
  //<<Respond to flags, Pr. \ref{pr:nev}>>
#+end_src
#+begin_export latex
  We import \ty{flag}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:nev}>>=
  "flag"
#+end_src
#+begin_export latex
  The server has a version flag (\ty{-v}). It runs on a host (\ty{-o}),
  where it listens at port (\ty{-p}). In addition, it may require a pair
  of public (\ty{-c}) and private keys (\ty{-k}) to run. A public key is
  also known as a \emph{certificate}, hence the \ty{-c} flag. The
  program \ty{never} accesses a database (\ty{-d}), either via one of
  the Neighbors program or directly. This database has been last updated
  at a time recorded in a file given via \ty{-u}.
#+end_export
#+begin_src go <<Declare flags, Pr. \ref{pr:nev}>>=
  flagV := flag.Bool("v", false, "version")
  flagO := flag.String("o", "localhost", "host")
  flagP := flag.String("p", "80", "port")
  flagC := flag.String("c", "", "certificate")
  flagK := flag.String("k", "", "private key")
  flagD := flag.String("d", "neidb", "database")
  flagU := flag.String("u", "updated.txt", "last updated")
#+end_src
#+begin_export latex
  We respond to the version flag, \ty{-v}, the database flag,
  \ty{-d}, and the updated flag, \ty{-u}.
#+end_export
#+begin_src go <<Respond to flags, Pr. \ref{pr:nev}>>=
  //<<Respond to \ty{-v}, Pr. \ref{pr:nev}>>
  //<<Respond to \ty{-d}, Pr. \ref{pr:nev}>>
  //<<Respond to \ty{-u}, Pr. \ref{pr:nev}>>
#+end_src
#+begin_export latex
If the user asked for the version, we print the program information,
which includes the version.
#+end_export
#+begin_src go <<Respond to \ty{-v}, Pr. \ref{pr:nev}>>=
  if *flagV {
	  util.PrintInfo()
  }
#+end_src
#+begin_export latex
In response to the database flag, we open the database. This
precipitates a fatal error if the database does not exist.
#+end_export
#+begin_src go <<Respond to \ty{-d}, Pr. \ref{pr:nev}>>=
  db := tdb.OpenTaxonomyDB(*flagD)
#+end_src
#+begin_export latex
We import \ty{tdb}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:nev}>>=
  "github.com/evolbioinf/neighbors/tdb"
#+end_src
#+begin_export latex
The usage consists of the actual usage message, an explanation of the
purpose of \ty{never}, and an example command.
#+end_export
#+begin_src go <<Set usage, Pr. \ref{pr:nev}>>=
  u := "never [flag]..."
  p := "The program never is a web server " +
	  "providing a REST API for the Neighbors package."
  e := "never -o 10.254.1.21 -c Cert.pem -k privateKey.pem"
  clio.Usage(u, p, e)
#+end_src
#+begin_export latex
  We import \ty{clio}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:nev}>>=
  "github.com/evolbioinf/clio"
#+end_src
#+begin_export latex
  We respond to the updated flag \ty{-u} by checking the file supplied
  actually exists and contains the seven strings that make up the date
  generated with the Unix command \ty{date}. If not, we bail.
#+end_export
#+begin_src go <<Respond to \ty{-u}, Pr. \ref{pr:nev}>>=
  date, err := os.ReadFile(*flagU)
  util.Check(err)
  tmpFields := bytes.Fields(date)
  if len(tmpFields) != 7 {
	  log.Fatalf("%q doesn't look like a date",
		  string(date))
  }
#+end_src
#+begin_export latex
We import \ty{os} and \ty{bytes}, and \ty{log}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:nev}>>=
  "os"
  "bytes"
  "log"
#+end_src
#+begin_export latex
\section{Front End}
We've finished writing the back end, so we turn to the front end. Here
first provide a start page. Then we do two kinds of things, we emulate
Neighbors programs and access functions of the package underlying
Neighbors, \ty{tdb}.
#+end_export
#+begin_src go <<Construct front end, Pr. \ref{pr:nev}>>=
  //<<Provide start page, Pr. \ref{pr:nev}>>
  //<<Emulate Neighbors programs, Pr. \ref{pr:nev}>>
  //<<Access \ty{tdb} functions, Pr. \ref{pr:nev}>>
#+end_src
#+begin_export latex
\subsection{Start Page}
At this early stage of development our start page is very simple. It
is implemented in the function \ty{echo} and just consists of a
welcome message and echos the URL path.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:nev}>>=
  func echo(w http.ResponseWriter, r *http.Request) {
	  m := "<h1>Welcome to Never, the Neighbors Server</h1>"
	  m += "This site is under construction, and for now only "
	  m += "provides echoing of the incoming URL (<code>%s</code>) and "
	  m += "an imitation of <a href=\"https://neighbors.evolbio.mpg.de/"
	  m += "?t=Homo%20sapiens&s=1\"><code>taxi</code>.</a>"
	  m = fmt.Sprintf(m, r.URL.Path)
	  fmt.Fprintf(w, "%s\n", m)
  }
#+end_src
#+begin_export latex
We import \ty{http} and \ty{fmt}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:nev}>>=
  "net/http"
  "fmt"
#+end_src
#+begin_export latex
We provide our start page by registering \ty{echo} at the root URL.
#+end_export
#+begin_src go <<Provide start page, Pr. \ref{pr:nev}>>=
  http.HandleFunc("/", echo)
#+end_src
#+begin_export latex
\subsection{Emulate Neighbors Programs}
\subsubsection{Emulate \ty{taxi}}
The program \ty{taxi} takes as input the name of a taxon and a
matching mode. It writes as response for each matching taxon the taxon
ID, its parent's taxon ID, and its scientific name. To store these
three items, we declare the \ty{struct} \ty{TaxiOut}.
#+end_export
#+begin_src go <<Types, Pr. \ref{pr:nev}>>=
  type TaxiOut struct {
	  Id int `json:"id"`
	  Parent int `json:"parent"`
	  Name string `json:"name"`
  }
#+end_src
#+begin_export latex
To obtain information from the Neighbors database, we create a type
that wraps \ty{tdb.TaxonomyDB}, to which we add methods that wrap
various queries.
#+end_export
#+begin_src go <<Types, Pr. \ref{pr:nev}>>=
  type MyDB struct {
	  db *tdb.TaxonomyDB
  }
#+end_src
#+begin_export latex
We add the method \ty{taxi} to \ty{MyDB}. The method \ty{taxi} is of
type \ty{http.Handler}, which has the signature
\begin{verbatim}
type HandlerFunc func(ResponseWriter, *Request)
\end{verbatim}
Inside \ty{taxi}, we extract the query from the HTTP request, query
the database, and write the result to the HTTP writer.
#+end_export
#+begin_src go <<Methods, Pr. \ref{pr:nev}>>=
  func (m MyDB) taxi(w http.ResponseWriter, r *http.Request) {
	  //<<Extract taxi query, Pr. \ref{pr:nev}>>
	  //<<Execute taxi query, Pr. \ref{pr:nev}>>
	  //<<Print taxi result, Pr. \ref{pr:nev}>>
  }
#+end_src
#+begin_export latex
We extract the taxon name and whether or not we are matching in
substring mode. If we \emph{are} matching in substring mode, we
replace blanks in the name by wild cards and also bracket the name by
wild cards.
#+end_export
#+begin_src go <<Extract taxi query, Pr. \ref{pr:nev}>>=
  name := r.URL.Query().Get("t")
  sstr := r.URL.Query().Get("s")
  if sstr == "1" && len(name) > 0 {
	  name = strings.ReplaceAll(name, " ", "%")
	  name = "%" + name + "%"
  }
#+end_src
#+begin_export latex
We import \ty{strings}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:nev}>>=
  "strings"
#+end_src
#+begin_export latex
The taxi query is executed in two phases. First, we get the matching
taxon IDs. Then we iterate over the taxon IDs and for each one
construct the taxon output and store it in our slice of \ty{TaxiOut}
items.
#+end_export
#+begin_src go <<Execute taxi query, Pr. \ref{pr:nev}>>=
  ids := m.db.Taxids(name)
  out := []TaxiOut{}
  for _, id := range ids {
	  //<<Construct taxon output, Pr. \ref{pr:nev}>>
	  //<<Store taxon output, Pr. \ref{pr:nev}>>
  }
#+end_src
#+begin_export latex
  We get the taxon's scientific name and parent. Then we construct the
  corresponding taxon output.
#+end_export
#+begin_src go <<Construct taxon output, Pr. \ref{pr:nev}>>=
  sciName := m.db.Name(id)
  parent := m.db.Parent(id)
  tout := TaxiOut{
	  Id: id,
	  Parent: parent,
	  Name: sciName}
#+end_src
#+begin_export latex
  We store the output item we just constructed in our slice of taxon
  output.
#+end_export
#+begin_src go <<Store taxon output, Pr. \ref{pr:nev}>>=
  out = append(out, tout)
#+end_src
#+begin_export latex
We convert the slice of taxi output to json format and write it to the
response writer.
#+end_export
#+begin_src go <<Print taxi result, Pr. \ref{pr:nev}>>=
  b, err := json.Marshal(out)
  util.Check(err)
  fmt.Fprintf(w, "%s", string(b))
#+end_src
#+begin_export latex
We import \ty{json}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:nev}>>=
  "encoding/json"
#+end_src
#+begin_export latex
All that remains to complete the emulation of the \ty{taxi} program,
is to create the database wrapper and to register its method \ty{taxi}
at the URL \ty{taxi}.
#+end_export
#+begin_src go <<Emulate Neighbors programs, Pr. \ref{pr:nev}>>=
  var myDB MyDB
  myDB.db = db
  http.HandleFunc("/taxi/", myDB.taxi)
#+end_src
#+begin_export latex
\subsection{Access \ty{tdb} Functions}
\subsubsection{\ty{Accessions}}
#+end_export
#+begin_src go <<Access \ty{tdb} functions, Pr. \ref{pr:nev}>>=
  fmt.Println("TO DO: Handle calls to tdb functions")
#+end_src
#+begin_export latex
  We import \ty{fmt}.
#+end_export
#+begin_export latex
We have built the server, now we can start it. If the user supplied a
pair of encryption keys, we start it as a HTTPS server, otherwise its
a HTTP server.
#+end_export
#+begin_src go <<Start server, Pr. \ref{pr:nev}>>=
  host := *flagO + ":" + *flagP
  if *flagC != "" && *flagK != "" {
	  log.Fatal(http.ListenAndServeTLS(host, *flagC,
		  ,*flagK, nil))
  } else {
	  log.Fatal(http.ListenAndServe(host, nil))
  }
#+end_src

