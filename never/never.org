#+begin_export latex
The program \ty{never} is a webserver that provides access to the
facilities of the Neighbors package; hence the name \emph{Neighbors
Sever}, or \ty{never}.

Our outline of \ty{never} contains hooks for imports, types,
variables, functions, and the logic of the main
function.\bpr{never}{pr:nev}
#+end_export
#+begin_src go <<never.go>>=
  package main

  import (
	  //<<Imports, Pr. \ref{pr:nev}>>
  )
  //<<Types, Pr. \ref{pr:nev}>>
  //<<Variables, Pr. \ref{pr:nev}>>
  //<<Functions, Pr. \ref{pr:nev}>>
  func main() {
	  //<<Main function, Pr. \ref{pr:nev}>>
  }
#+end_src
#+begin_export latex
\epr In the main function we prepare logging, before we construct the
server and start it.
#+end_export
#+begin_src go <<Main function, Pr. \ref{pr:nev}>>=
  util.PrepLog("never")
  //<<Construct server, Pr. \ref{pr:nev}>>
  //<<Start server, Pr. \ref{pr:nev}>>
#+end_src
#+begin_export latex
We import \ty{util}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:nev}>>=
  "github.com/evolbioinf/never/util"
#+end_src
#+begin_export latex
Our web server, like any web server, consists of two parts, a front
end and a back end. The front end consists of the things seen by the
user via a browser. This often consists of web pages, but may be as
light weight as a URL extended by a query.

The back end consists of a command-line program seen by the sysadmin
who starts the server. The back end is easier to write than the front
end, so we start with it.
#+end_export
#+begin_src go <<Construct server, Pr. \ref{pr:nev}>>=
  //<<Construct back end, Pr. \ref{pr:nev}>>
  //<<Construct front end, Pr. \ref{pr:nev}>>
#+end_src
#+begin_export latex
  \section{Back End}
  In the back end we declare the flags, set the usage, parse the
  flags, and respond to them.
#+end_export
#+begin_src go <<Construct back end, Pr. \ref{pr:nev}>>=
  //<<Declare flags, Pr. \ref{pr:nev}>>
  //<<Set usage, Pr. \ref{pr:nev}>>
  flag.Parse()
  //<<Respond to flags, Pr. \ref{pr:nev}>>
#+end_src
#+begin_export latex
  We import \ty{flag}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:nev}>>=
  "flag"
#+end_src
#+begin_export latex
The server has a version flag (\ty{-v}). It runs on a host (\ty{-o}),
where it listens at a port (\ty{-p}). In addition, it may require a
pair of public (\ty{-c}) and private keys (\ty{-k}) to run. A public
key is also known as a \emph{certificate}, hence the \ty{-c} flag. The
program \ty{never} accesses a database (\ty{-d}), either via one of
the Neighbors program or directly. This database has been last updated
at a time recorded in a file given via \ty{-u}.
#+end_export
#+begin_src go <<Declare flags, Pr. \ref{pr:nev}>>=
  flagV := flag.Bool("v", false, "version")
  flagO := flag.String("o", "localhost", "host")
  flagP := flag.String("p", "443", "port")
  flagC := flag.String("c", "", "certificate")
  flagK := flag.String("k", "", "private key")
  flagD := flag.String("d", "neidb", "database")
  flagU := flag.String("u", "updated.txt", "last updated")
#+end_src
#+begin_export latex
The usage consists of the actual usage message, an explanation of the
purpose of \ty{never}, and an example command.
#+end_export
#+begin_src go <<Set usage, Pr. \ref{pr:nev}>>=
  u := "never [flag]..."
  p := "The program never is a web server " +
	  "providing a REST API for the Neighbors package."
  e := "never -o 10.254.1.21 -c Cert.pem -k privateKey.pem"
  clio.Usage(u, p, e)
#+end_src
#+begin_export latex
  We import \ty{clio}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:nev}>>=
  "github.com/evolbioinf/clio"
#+end_src
#+begin_export latex
We respond to the version flag, \ty{-v}, the host (\ty{-o}) and port
(\ty{-p}) flags, the database flag, \ty{-d}, and the updated flag,
\ty{-u}.
#+end_export
#+begin_src go <<Respond to flags, Pr. \ref{pr:nev}>>=
  //<<Respond to \ty{-v}, Pr. \ref{pr:nev}>>
  //<<Respond to \ty{-o} and \ty{-p}, Pr. \ref{pr:nev}>>
  //<<Respond to \ty{-d}, Pr. \ref{pr:nev}>>
  //<<Respond to \ty{-u}, Pr. \ref{pr:nev}>>
#+end_src
#+begin_export latex
If the user asked for the version, we print the program information,
which includes the version.
#+end_export
#+begin_src go <<Respond to \ty{-v}, Pr. \ref{pr:nev}>>=
  if *flagV {
	  util.PrintInfo()
  }
#+end_src
#+begin_export latex
We make host and port global variables for easy access from within the
HTTP handler functions we write later on. So we declare them as string
variables.
#+end_export
#+begin_src go <<Variables, Pr. \ref{pr:nev}>>=
  var host, port string
#+end_src
#+begin_export latex
And we assign the host and port flags to their global counterparts.
#+end_export
#+begin_src go <<Respond to \ty{-o} and \ty{-p}, Pr. \ref{pr:nev}>>=
  host = *flagO
  port = *flagP
#+end_src
#+begin_export latex
In response to the database flag, we open the database. This
precipitates a fatal error if the database does not exist.
#+end_export
#+begin_src go <<Respond to \ty{-d}, Pr. \ref{pr:nev}>>=
  neidb = tdb.OpenTaxonomyDB(*flagD)
#+end_src
#+begin_export latex
We declare the variable \ty{neidb} global to make it easily accessible
from the various http handlers we shall write.
#+end_export
#+begin_src go <<Variables, Pr. \ref{pr:nev}>>=
  var neidb *tdb.TaxonomyDB
#+end_src
#+begin_export latex
We import \ty{tdb}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:nev}>>=
  "github.com/evolbioinf/neighbors/tdb"
#+end_src
#+begin_export latex
We respond to the updated flag \ty{-u} by checking the file supplied
actually exists and contains the seven strings that make up the date
generated with the Unix command \ty{date}. If not, we bail. If
everything is ok, we set the name of the file to the global variable
\ty{dateFile} so we can load it whenever the top page of \ty{never} is
called.
#+end_export
#+begin_src go <<Respond to \ty{-u}, Pr. \ref{pr:nev}>>=
  date, err := os.ReadFile(*flagU)
  util.Check(err)
  tmpFields := bytes.Fields(date)
  if len(tmpFields) != 7 {
	  log.Fatalf("%q doesn't look like a date",
		  string(date))
  }
  dateFile = *flagU
#+end_src
#+begin_export latex
We import \ty{os} and \ty{bytes}, and \ty{log}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:nev}>>=
  "os"
  "bytes"
  "log"
#+end_src
#+begin_export latex
We declare \ty{dateFile}.
#+end_export
#+begin_src go <<Variables, Pr. \ref{pr:nev}>>=
  var dateFile string
#+end_src
#+begin_export latex
\section{Front End}
We've finished writing the back end, so we turn to the front end. This
consists of a set of HTML pages, which depend on style files we serve
first of all. The HTML files themselves are divided into three
categories. First, there is the start, or \emph{index} page, then
there are pages to emulate Neighbors programs, and finally there are
pages giving access to \ty{tdb} functions.
#+end_export
#+begin_src go <<Construct front end, Pr. \ref{pr:nev}>>=
  //<<Serve style files, Pr. \ref{pr:nev}>>
  //<<Construct index page, Pr. \ref{pr:nev}>>
  //<<Emulate Neighbors programs, Pr. \ref{pr:nev}>>
  //<<Access \ty{tdb} functions, Pr. \ref{pr:nev}>>
#+end_src
#+begin_export latex
\subsection{ Files}
The style files are locate in the directory \ty{static}. We make them
available by registering a file server to that directory.
#+end_export
#+begin_src go <<Serve style files, Pr. \ref{pr:nev}>>=
  files := http.FileServer(http.Dir("static"))
  http.Handle("/static/", http.StripPrefix("/static/", files))
#+end_src
#+begin_export latex
We import \ty{http}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:nev}>>=
  "net/http"
#+end_src
#+begin_export latex
\subsection{Start Page}
HTML pages are written in response to two data sources. The first data
source is the HTTP request sent by the client. We can think of this as
``external'' data. The second data source is ``internal'' data, for
example the page title. The HTTP request is covered by the type
\verb+http.Request+, but the page data is too varied for a standard
type, so we declare the struct \ty{PageData} and add fields to it as
we go along.
#+end_export
#+begin_src go <<Types, Pr. \ref{pr:nev}>>=
  type PageData struct {
	  //<<\ty{PageData} fields, Pr. \ref{pr:nev}>>
  }
#+end_src
#+begin_export latex
We construct the start, or \emph{index}, page using the function
\ty{index}. It takes three arguments, a writer for sending data down
the HTTP channel, a reader for obtaining data from the HTTP channel,
and internal data. We set the page's data and costruct it it by executing a
HTML template we still need to write. We check the error returned from
executing the template.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:nev}>>=
  func index(w http.ResponseWriter, r *http.Request, p *PageData) {
	  //<<Set index page data, Pr. \ref{pr:nev}>>
	  err = templates.ExecuteTemplate(w, "index", p)
	  if err != nil {
		  http.Error(w, err.Error(), http.StatusInternalServerError)
		  return
	  }
  }
#+end_src
#+begin_export latex
As page data we set the title and the list of services offered. This
list is potentially long, so we sort it. We also set the number of
genomes and taxa, and when the database was last updated. The numbers
of genomes and taxa are of the order of three million, so we make them
easier to read by inserting commas.
#+end_export
#+begin_src go <<Set index page data, Pr. \ref{pr:nev}>>=
  p.Title = "Neighbors"
  p.Services = services
  //<<Sort services, Pr. \ref{pr:nev}>>
  nt, err := neidb.NumTaxa()
  util.CheckHTTP(w, err)
  p.Ntaxa = humanize.Comma(int64(nt))
  ng, err := neidb.NumGenomes()
  util.CheckHTTP(w, err)
  p.Ngenomes = humanize.Comma(int64(ng))
  //<<Set database time stamp, Pr. \ref{pr:nev}>>
#+end_src
#+begin_export latex
We import \ty{humanize}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:nev}>>=
  "github.com/dustin/go-humanize"
#+end_src
#+begin_export latex
We declare the fields \ty{Title}, \ty{Services}, \ty{Ngenomes},
\ty{Ntaxa}, and \ty{Date} in \ty{PageData}.
#+end_export
#+begin_src go <<\ty{PageData} fields, Pr. \ref{pr:nev}>>=
  Title, URL, Date, Ngenomes, Ntaxa string
  Services []Service
#+end_src
#+begin_export latex
The variable \ty{services} is a global slice of services.
#+end_export
#+begin_src go <<Variables, Pr. \ref{pr:nev}>>=
  var services []Service
#+end_src
#+begin_export latex
We need to fill the table of services \emph{before} the index page is
constructed for the first time. So we declare an \ty{init} function
with a hook for adding services.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:nev}>>=
  func init() {
	  //<<Add services, Pr. \ref{pr:nev}>>
  }
#+end_src
#+begin_export latex
We sort the services by their name.
#+end_export
#+begin_src go <<Sort services, Pr. \ref{pr:nev}>>=
  slices.SortFunc(p.Services, func(a, b Service) int {
	  return strings.Compare(a.Name, b.Name)
  })
#+end_src
#+begin_export latex
We import \ty{slices} and \ty{strings}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:nev}>>=
  "slices"
  "strings"
#+end_src
#+begin_export latex
To set the time stamp of the database, we read the content of the date
file, which has the format
\begin{verbatim}
Thu May 22 02:00:01 AM CEST 2025
\end{verbatim}
We reformat this to the more friendly
\begin{verbatim}
May 22 2025 at 02:00:01 AM CEST
\end{verbatim}
#+end_export
#+begin_src go <<Set database time stamp, Pr. \ref{pr:nev}>>=
  date, err := os.ReadFile(dateFile)
  util.CheckHTTP(w, err)
  fields := strings.Fields(string(date))
  p.Date = fmt.Sprintf("%s %s %s at %s %s %s",
	  fields[1],
	  fields[2],
	  fields[6],
	  fields[3],
	  fields[4],
	  fields[5])

#+end_src
#+begin_export latex
We import \ty{fmt}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:nev}>>=
  "fmt"
#+end_src
#+begin_export latex
We also declare and initialize the variable \ty{templates}, which
holds the templates from which we generate HTML pages.
#+end_export
#+begin_src go <<Variables, Pr. \ref{pr:nev}>>=
  var templates = template.New("templates")
#+end_src
#+begin_export latex
We import \ty{template}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:nev}>>=
  "html/template"
#+end_src
#+begin_export latex
Figure~\ref{fig:idx} is a sketch of the index page. It consists two
main parts, the head and the body, separated by the horizontal
line. The body consists of a title, a description, and tables of the
functions and programs accessible via the server. Each row in these
tables consists of a number, a name, and an example query presented as
a hyperlink.
\begin{figure}
  \input{../never/index}
\caption{Sketch of the index page of \ty{never}.}\label{fig:idx}
\end{figure}
To store a service, we declare it as a \ty{struct} holding a name
and a query.
#+end_export
#+begin_src go <<Types, Pr. \ref{pr:nev}>>=
  type Service struct {
	  Name, Query string
  }
#+end_src
#+begin_export latex
We write all templates to the file \ty{templates.html}. In our first
template \ty{index}, we declare sub-templates for a generic head and
an index-specific body.
#+end_export
#+begin_src html <<templates.html>>=
  {{define "index"}}
  <!DOCTYPE html>
  <html lang="en">
    <head>
      {{template "head" .}}
    </head>
    <body>
      {{template "indexBody" .}}
    </body>
  </html>
  {{end}}
#+end_src
#+begin_export latex
In the head template we set the character set, the page layout, and
the location of the style file. Then we set the page title.
#+end_export
#+begin_src html <<templates.html>>=
  {{define "head"}}
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <link rel="stylesheet" href="./static/w3.css"/>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <title>{{.Title}}</title>
  {{end}}
#+end_src
#+begin_export latex
In the body template we declare templates for the title, the
description and the lists of services.
#+end_export
#+begin_src html <<templates.html>>=
  {{define "indexBody"}}
  {{template "indexTitle"}}
  {{template "indexDescr" .}}
  {{template "services" .Services}}
  {{end}}
#+end_src
#+begin_export latex
We set the title.
#+end_export
#+begin_src html <<templates.html>>=
  {{define "indexTitle"}}
  <div class="w3-container">
    <h1>Welcome to the Neighbors REST API</h1>
  </div>
  {{end}}
#+end_src
#+begin_export latex
We introduce our server, describe the Neighbor method, and give some
background to it. We also quote the number of taxa and genomes in the
database and when it was last updated.
#+end_export
#+begin_src html <<templates.html>>=
  {{define "indexDescr"}}
  <div class="w3-container">
    //<<Introduce the Neighbors server, Pr. \ref{pr:nev}>>
    //<<Describe the Neighbors method, Pr. \ref{pr:nev}>>
    //<<Give some background to Neighbors, Pr. \ref{pr:nev}>>
    //<<Print number of taxa and genomes in database, Pr. \ref{pr:nev}>>
    //<<Print when database was last updated, Pr. \ref{pr:nev}>>	
   </div>
  {{end}}
#+end_src
#+begin_export latex
We give a quick introduction to the Neighbors server.
#+end_export
#+begin_src html <<Introduce the Neighbors server, Pr. \ref{pr:nev}>>=
  <p>
    The Neighbors REST API gives access to the accessions of genome
    sequences via the taxonomy of sequenced life.
  </p>
#+end_src
#+begin_export latex
We describe the Neighbors method of comparative marker discovery.
#+end_export
#+begin_src html <<Describe the Neighbors method, Pr. \ref{pr:nev}>>=
  <p>
    Starting from one or more target organisms, their genomes can be
    looked up. In addition, the genomes of the targets' closest
    relatives, their <i>neighbors</i> can be looked up. Such pairs of
    samples of target and neighbor genomes make good starting material
    for developing diagnostic markers.
  </p>
#+end_src
#+begin_export latex
As background, we list our data sources, credit the authors of the
server, and quote the Fur paper.
#+end_export
#+begin_src html <<Give some background to Neighbors, Pr. \ref{pr:nev}>>=
  <p>
    //<<List data sources, Pr. \ref{pr:nev}>>
    //<<Give credit for server, Pr. \ref{pr:nev}>>
    //<<Quote our Fur paper, Pr. \ref{pr:nev}>>
  </p>
#+end_src
#+begin_export latex
We list the NCBI as source of our raw data.
#+end_export
#+begin_src html <<List data sources, Pr. \ref{pr:nev}>>=
  We use
  the <a href="https://ftp.ncbi.nlm.nih.gov/pub/taxonomy/">taxonomy</a>
  and <a href="https://ftp.ncbi.nlm.nih.gov/genomes/ASSEMBLY_REPORTS">genome
  data</a> supplied by
  the <a href="https://www.ncbi.nlm.nih.gov/">NCBI</a> to build a custom
  database.
#+end_src
#+begin_export latex
Our server is a group effort, as is the underlying Neighbors package.
#+end_export
#+begin_src html <<Give credit for server, Pr. \ref{pr:nev}>>=
  Our REST API for querying this database is developed by
  the <a href="https://evolbioinf.github.io/">Research Group
  Bioinformatics</a> at
  the <a href="https://evolbio.mpg.de">Max-Planck-Institute for
  Evolutionary Biology</a> using
  our <a href="https://github.com/evolbioinf/neighbors">Neighbors</a>
  package.
#+end_src
#+begin_export latex
We quote our second Fur paper.
#+end_export
#+begin_src html <<Quote our Fur paper, Pr. \ref{pr:nev}>>=
  For details on marker discovery with Neighbors and related software,
  please read
  our <a href="https://doi.org/10.1093/bioadv/vbae113">publication</a>.
#+end_src
#+begin_export latex
We get the number of taxa and genomes in a table.
#+end_export
#+begin_src html <<Print number of taxa and genomes in database, Pr. \ref{pr:nev}>>=
  <p>
    <table>
      <tr>
	<td>Number of taxa</td>
	<td>{{.Ntaxa}}</td>
      </tr>
      <tr>
	<td>Number of genomes</td>
	<td>{{.Ngenomes}}</td>
      </tr>
    </table>
  </p>
#+end_src
#+begin_export latex
We print the database time stamp.
#+end_export
#+begin_src go <<Print when database was last updated, Pr. \ref{pr:nev}>>=
  <p>
	  The database was last updated on {{.Date}}.
  </p>
#+end_src
#+begin_export latex
We define the template for printing the services, which calls a
template for printing a table.
#+end_export
#+begin_src html <<templates.html>>=
  {{define "services"}}
  <div class="w3-container">
    <h2>Services</h2>
    <table class="w3-container">
      {{template "table" .}}
    </table>
  </div>
  {{end}}
#+end_src
#+begin_export latex
The table consists of a header and a body.
#+end_export
#+begin_src html <<templates.html>>=
  {{define "table"}}
  {{template "header"}}
  {{template "body" .}}
  {{end}}
#+end_src
#+begin_export latex
The table consists of four columns, number, name, query, and link. We
write a header for each one.
#+end_export
#+begin_src html <<templates.html>>=
  {{define "header"}}
  <tr>
    <th>#</th>
    <th>Name</th>
    <th>Query</th>
  </tr>
  {{end}}
#+end_src
#+begin_export latex
To write the body of the table, we iterate over its rows and write the
index, name, and link as sketched in Figure~\ref{fig:idx}.
#+end_export
#+begin_src html <<templates.html>>=
  {{define "body"}}
  {{range $i, $e := .}}
  <tr>
    <td>{{inc $i}}</td>
    <td>{{.Name}}</td>
    <td><a href="{{.Name}}{{.Query}}"><code>{{.Query}}</code></td>
  </tr>
  {{end}}
  {{end}}
#+end_src
#+begin_export latex
The function \ty{inc} increments its argument.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:nev}>>=
  func inc(i int) int {
	  return i + 1
  }
#+end_src
#+begin_export latex
In order to associate \ty{inc} with our templates, we create a
function map.
#+end_export
#+begin_src go <<Variables, Pr. \ref{pr:nev}>>=
  var templateFuncs = make(template.FuncMap)
#+end_src
#+begin_export latex
This function map needs to be filled with the associated functions and
added to the our collection of templates \emph{before} we use any of
them. To ensure this, we declare an \ty{init} function, in which we
add the template functions to their map and then add the map to the
templates. Having added the functions to the templates, we can carry
ou the initial parsing of the templates. We have written these to the
file \ty{templates.html}, which we keep in the directory \ty{static}.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:nev}>>=
  func init() {
	  //<<Add template functions, Pr. \ref{pr:nev}>>
	  templates = templates.Funcs(templateFuncs)
	  path := "./static/templates.html"
	  templates = template.Must(templates.ParseFiles(path))
  }
#+end_src
#+begin_export latex
We add the template function \ty{inc}.
#+end_export
#+begin_src go <<Add template functions, Pr. \ref{pr:nev}>>=
  templateFuncs["inc"] = inc
#+end_src
#+begin_export latex
We have now written the index page, but still need to register it as
the handler for a given pattern. However, we can only register
functions of type \ty{HandlerFunc}. These have two arguments, a
response writer and a request, while \ty{index} has three arguments,
writer, request, and page data. So we convert \ty{index} to a handler
function using a dedicated function, \ty{makeHandler}.

The function \ty{makeHandler} takes as argument an ordinary function
with three arguments, writer, reader, and data. It generates a new
variable for holding the page data and returns a handler
function. Inside that handler function we set the writer such that it
allows access from all domains. Then we call the ordinary function
passed with the reader, the adjusted writer, and the new page data as
arguments.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:nev}>>=
  func makeHandler(fn func(http.ResponseWriter, *http.Request,
	  ,*PageData)) http.HandlerFunc {
	  p := new(PageData)
	  return func(w http.ResponseWriter, r *http.Request) {
		  w.Header().Set("Access-Control-Allow-Origin", "*")
		  fn(w, r, p)
	  }
  }
#+end_src
#+begin_export latex
We register \ty{index} as the function that handles calls to the root
of our web site.
#+end_export
#+begin_src go <<Construct index page, Pr. \ref{pr:nev}>>=
  http.HandleFunc("/", makeHandler(index))
#+end_src
#+begin_export latex
\subsection{Emulate Neighbors Programs}
\subsubsection{\ty{taxi}}
The service \ty{taxi} takes as input the name of a taxon and a
matching mode. It writes as response for each matching taxon the taxon
ID, its parent's taxon ID, and its scientific name. To store these
three items, we declare the \ty{struct} \ty{TaxiOut}.
#+end_export
#+begin_src go <<Types, Pr. \ref{pr:nev}>>=
  type TaxiOut struct {
	  Taxid int `json:"taxid"`
	  Parent int `json:"parent"`
	  Name string `json:"name"`
  }
#+end_src
#+begin_export latex
We write \ty{taxi} on the same pattern as \ty{index}.  Inside
\ty{taxi}, we extract the query from the HTTP request, query the
database, and write the result to the HTTP writer.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:nev}>>=
  func taxi(w http.ResponseWriter, r *http.Request, p *PageData) {
	  //<<Extract taxi query, Pr. \ref{pr:nev}>>
	  //<<Execute taxi query, Pr. \ref{pr:nev}>>
	  //<<Print taxi result, Pr. \ref{pr:nev}>>
  }
#+end_src
#+begin_export latex
We extract the taxon name and whether or not we are matching in exact
mode. If we are \emph{not} matching in substring mode, we replace
blanks in the name by wild cards and also bracket the name by wild
cards.
#+end_export
#+begin_src go <<Extract taxi query, Pr. \ref{pr:nev}>>=
  name := r.URL.Query().Get("t")
  sstr := r.URL.Query().Get("e")
  if sstr != "1" && len(name) > 0 {
	  name = strings.ReplaceAll(name, " ", "%")
	  name = "%" + name + "%"
  }
#+end_src
#+begin_export latex
The taxi query is executed in two phases. First, we get the matching
taxon IDs. Then we iterate over the taxon IDs and for each one
construct the taxon output and store it in our slice of \ty{TaxiOut}
items.
#+end_export
#+begin_src go <<Execute taxi query, Pr. \ref{pr:nev}>>=
  ids, err := neidb.Taxids(name)
  util.CheckHTTP(w, err)
  out := []TaxiOut{}
  for _, id := range ids {
	  //<<Construct taxon output, Pr. \ref{pr:nev}>>
	  //<<Store taxon output, Pr. \ref{pr:nev}>>
  }
#+end_src
#+begin_export latex
  We get the taxon's scientific name and parent. Then we construct the
  corresponding taxon output.
#+end_export
#+begin_src go <<Construct taxon output, Pr. \ref{pr:nev}>>=
  sciName, err := neidb.Name(id)
  util.CheckHTTP(w, err)
  parent, err := neidb.Parent(id)
  util.CheckHTTP(w, err)
  tout := TaxiOut{
	  Taxid: id,
	  Parent: parent,
	  Name: sciName}
#+end_src
#+begin_export latex
  We store the output item we just constructed in our slice of taxon
  output.
#+end_export
#+begin_src go <<Store taxon output, Pr. \ref{pr:nev}>>=
  out = append(out, tout)
#+end_src
#+begin_export latex
We convert the slice of taxi output to JSON format and write it to the
response writer.
#+end_export
#+begin_src go <<Print taxi result, Pr. \ref{pr:nev}>>=
  b, err := json.Marshal(out)
  util.Check(err)
  fmt.Fprintf(w, "%s\n", string(b))
#+end_src
#+begin_export latex
We import \ty{json}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:nev}>>=
  "encoding/json"
  "fmt"
#+end_src
#+begin_export latex
We can now emulate of the \ty{taxi} program by registering the
service \ty{taxi} to the URL \verb+/taxi/+.
#+end_export
#+begin_src go <<Emulate Neighbors programs, Pr. \ref{pr:nev}>>=
  http.HandleFunc("/taxi/", makeHandler(taxi))
#+end_src
#+begin_export latex
We also add the \ty{taxi} service to our list of services.
#+end_export
#+begin_src go <<Add services, Pr. \ref{pr:nev}>>=
  query := "?t=Homo+sapiens&e=1"
  service := Service{Name: "taxi", Query: query}
  services = append(services, service)
#+end_src
#+begin_export latex
\subsection{Access \ty{tdb} Functions}
\subsubsection{\ty{accessions}}
The service \ty{accessions} takes as argument a taxon ID and returns
the corresponding genome accessions as a slice of strings. We store
its output in the struct \ty{Accession}, which wraps a single
accession.
#+end_export
#+begin_src go <<Types, Pr. \ref{pr:nev}>>=
  type Accession struct {
	  Accession string `json:"accession"`
  }
#+end_src
#+begin_export latex
We implement the service in the function \ty{accessions}. Inside of
\ty{accessions}, we get the taxon ID and from it the accessions,
before we print the output.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:nev}>>=
  func accessions(w http.ResponseWriter, r *http.Request, p *PageData) {
	  taxid := getTaxa(w, r)[0]
	  //<<Get accessions, Pr. \ref{pr:nev}>>
	  //<<Print output, Pr. \ref{pr:nev}>>
  }
#+end_src
#+begin_export latex
The function \ty{getTaxa} takes as input a HTTP request and returns
the taxa passed. The taxa are comma-delimited and arrive as the value
of key \ty{t}.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:nev}>>=
  func getTaxa(w http.ResponseWriter, r *http.Request) []int {
	  taxa := []int{}
	  t := r.URL.Query().Get("t")
	  tokes := strings.Split(t, ",")
	  for _, token := range tokes {
		  taxon, err := strconv.Atoi(token)
		  util.CheckHTTP(w, err)
		  taxa = append(taxa, taxon)
	  }
	  return taxa
  }
#+end_src
#+begin_export latex
We import \ty{strconv}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:nev}>>=
  "strconv"
#+end_src
#+begin_export latex
We get the accessions and store them in a slice of accessions.
#+end_export
#+begin_src go <<Get accessions, Pr. \ref{pr:nev}>>=
  out := []Accession{}
  accs, err := neidb.Accessions(taxid)
  util.CheckHTTP(w, err)
  for _, acc := range accs {
	  o := Accession{acc}
	  out = append(out, o)
  }
#+end_src
#+begin_export latex
We convert our slice of accession items to JSON and print it as our
response.
#+end_export
#+begin_src go <<Print output, Pr. \ref{pr:nev}>>=
  b, err := json.Marshal(out)
  util.CheckHTTP(w, err)
  fmt.Fprintf(w, "%s\n", string(b))
#+end_src
#+begin_export latex
We are done writing \ty{accessions}. So we convert it to a handler
function and register it.
#+end_export
#+begin_src go <<Access \ty{tdb} functions, Pr. \ref{pr:nev}>>=
  http.HandleFunc("/accessions/", makeHandler(accessions))
#+end_src
#+begin_export latex
We also add \ty{accessions} to our list of services.
#+end_export
#+begin_src go <<Add services, Pr. \ref{pr:nev}>>=
  query = "?t=9606"
  service = Service{Name: "accessions",
	  Query: query}
  services = append(services, service)
#+end_src
#+begin_export latex
\subsubsection{\ty{names}}
The service \ty{names} takes a as argument a list of taxon IDs and
returns the corresponding scientific names. We store its output in the
struct \ty{Name}, which wraps a taxid/name pair.
#+end_export
#+begin_src go <<Types, Pr. \ref{pr:nev}>>=
  type Name struct {
	  Taxid int `json:"taxid"`
	  Name string `json:"name"`
  }
#+end_src
#+begin_export latex
The query is implemented in the service \ty{names}. Inside \ty{names},
we get the taxon IDs and the corresponding names, before we print the
output.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:nev}>>=
  func names(w http.ResponseWriter, r *http.Request, p *PageData) {
	  taxa := getTaxa(w, r)
	  out := []Name{}
	  for i, taxon := range taxa {
		  name, err := neidb.Name(taxon)
		  util.CheckHTTP(w, err)
		  o := Name{Taxid: taxa[i], Name: name}
		  out = append(out, o)
	  }
	  //<<Print output, Pr. \ref{pr:nev}>>
  }
#+end_src
#+begin_export latex
We convert \ty{names} to a handler function and register it.
#+end_export
#+begin_src go <<Access \ty{tdb} functions, Pr. \ref{pr:nev}>>=
  http.HandleFunc("/names/", makeHandler(names))
#+end_src
#+begin_export latex
We also add \ty{names} to our list of services.
#+end_export
#+begin_src go <<Add services, Pr. \ref{pr:nev}>>=
  queries := query + ",9605"
  service = Service{Name: "names",
	  Query: queries}
  services = append(services, service)
#+end_src
#+begin_export latex
\subsubsection{\ty{ranks}}
The service \ty{ranks} takes as argument a list of taxon IDs and
returns their ranks. We store the output in a slice with elements of
type \ty{Rank}, which wraps a taxid/rank pair.
#+end_export
#+begin_src go <<Types, Pr. \ref{pr:nev}>>=
  type Rank struct {
	  Taxid int `json:"taxid"`
	  Rank string `json:"rank"`
  }
#+end_src
#+begin_export latex
In the function \ty{ranks} we get the taxon IDs, query store the
corresponding ranks, and print the output.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:nev}>>=
  func ranks(w http.ResponseWriter, r *http.Request, p *PageData) {
	  taxa := getTaxa(w, r)
	  out := []Rank{}
	  for i, taxon := range taxa {
		  rank, err := neidb.Rank(taxon)
		  util.CheckHTTP(w, err)
		  o := Rank{Taxid: taxa[i], Rank: rank}
		  out = append(out, o)
	  }
	  //<<Print output, Pr. \ref{pr:nev}>>
  }
#+end_src
#+begin_export latex
We convert \ty{ranks} to a handler function and register it.
#+end_export
#+begin_src go <<Access \ty{tdb} functions, Pr. \ref{pr:nev}>>=
  http.HandleFunc("/ranks/", makeHandler(ranks))
#+end_src
#+begin_export latex
We also add \ty{ranks} to our list of services.
#+end_export
#+begin_src go <<Add services, Pr. \ref{pr:nev}>>=
  service = Service{Name: "ranks",
	  Query: queries}
  services = append(services, service)
#+end_src
#+begin_export latex
\subsubsection{\ty{parent}}
The service \ty{parent} takes as argument a taxon ID and returns the
parent's taxon ID. We store its output in a \ty{struct} that wraps a
single taxon ID, or taxid.
#+end_export
#+begin_src go <<Types, Pr. \ref{pr:nev}>>=
  type Taxid struct {
	  Taxid int `json:"taxid"`
  }
#+end_src
#+begin_export latex
In the function \ty{parent} we get the taxon ID, look up the parent,
and print the output.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:nev}>>=
  func parent(w http.ResponseWriter, r *http.Request, p *PageData) {
	  taxon := getTaxa(w, r)[0]
	  parent, err := neidb.Parent(taxon)
	  util.CheckHTTP(w, err)
	  out := Taxid{parent}
	  //<<Print output, Pr. \ref{pr:nev}>>
  }
#+end_src
#+begin_export latex
We register \ty{parent}.
#+end_export
#+begin_src go <<Access \ty{tdb} functions, Pr. \ref{pr:nev}>>=
  http.HandleFunc("/parent/", makeHandler(parent))
#+end_src
#+begin_export latex
We also add \ty{parent} to our list of services.
#+end_export
#+begin_src go <<Add services, Pr. \ref{pr:nev}>>=
  service = Service{Name: "parent",
	  Query: query}
  services = append(services, service)
#+end_src
#+begin_export latex
\subsubsection{\ty{children}}
The service \ty{children} takes as argument a taxon ID and returns its
children as a slice of their taxon IDs.  We implement it in the
function \ty{children}, where we get the taxon ID and the
corresponding children, before we print the output.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:nev}>>=
  func children(w http.ResponseWriter, r *http.Request, p *PageData) {
	  taxon := getTaxa(w, r)[0]
	  out := []Taxid{}
	  children, err := neidb.Children(taxon)
	  util.CheckHTTP(w, err)
	  for _, child := range children {
		  o := Taxid{child}
		  out = append(out, o)
	  }
	  //<<Print output, Pr. \ref{pr:nev}>>
  }
#+end_src
#+begin_export latex
We register \ty{children}.
#+end_export
#+begin_src go <<Access \ty{tdb} functions, Pr. \ref{pr:nev}>>=
  http.HandleFunc("/children/", makeHandler(children))
#+end_src
#+begin_export latex
We also add \ty{children} to our list of services.
#+end_export
#+begin_src go <<Add services, Pr. \ref{pr:nev}>>=
  service = Service{Name: "children",
	  Query: query}
  services = append(services, service)
#+end_src
#+begin_export latex
\subsubsection{\ty{subtree}}
The service \ty{subtree} returns all taxa in a subtree, including the
root. In the function \ty{subtree} we get the taxon ID, get and store
the corresponding subtree, and print the output.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:nev}>>=
  func subtree(w http.ResponseWriter, r *http.Request, p *PageData) {
	  taxon := getTaxa(w, r)[0]
	  taxids, err := neidb.Subtree(taxon)
	  util.CheckHTTP(w, err)
	  out := []Taxid{}
	  for _, taxid := range taxids {
		  o := Taxid{taxid}
		  out = append(out, o)
	  }
	  //<<Print output, Pr. \ref{pr:nev}>>
  }
#+end_src
#+begin_export latex
We register \ty{subtree}.
#+end_export
#+begin_src go <<Access \ty{tdb} functions, Pr. \ref{pr:nev}>>=
  http.HandleFunc("/subtree/", makeHandler(subtree))
#+end_src
#+begin_export latex
We also add \ty{subtree} to our list of services.
#+end_export
#+begin_src go <<Add functions to table, Pr. \ref{pr:nev}>>=
  service = Service{Name: "subtree",
	  Query: query}
  services = append(services, service)
#+end_src
#+begin_export latex
\subsubsection{\ty{Taxids}}
The function \ty{Taxids} takes as argument a taxon name and returns
the corresponding taxon IDs. We implement the query in the function
\ty{taxids} where we get the taxon name and store the corresponding
taxon IDs before we print the output.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:nev}>>=
  func taxids(w http.ResponseWriter, r *http.Request, p *PageData) {
	  name := r.URL.Query().Get("t")
	  out := []Taxid{}
	  taxids, err := neidb.Taxids(name)
	  util.CheckHTTP(w, err)
	  for _, taxid := range taxids {
		  o := Taxid{taxid}
		  out = append(out, o)
	  }
	  //<<Print output, Pr. \ref{pr:nev}>>
  }
#+end_src
#+begin_export latex
We register \ty{taxids}.
#+end_export
#+begin_src go <<Access \ty{tdb} functions, Pr. \ref{pr:nev}>>=
  http.HandleFunc("/taxids/", makeHandler(taxids))
#+end_src
#+begin_export latex
We also add \ty{taxids} to the list of services.
#+end_export
#+begin_src go <<Add services, Pr. \ref{pr:nev}>>=
  query = "?t=Homo+sapiens"
  service = Service{Name: "taxids",
	  Query: query}
  services = append(services, service)
#+end_src

#+begin_export latex
\subsubsection{\ty{MRCA}}
The function \ty{MRCA} taks as argument a slice of taxon IDs and
returns their most recent comon ancestor. We store the output in a
strcutre that wraps a single 
#+end_export
#+begin_export latex
We implement the query for
the most recent common ancestor in the function \ty{mrca}, in which we
get the taxon IDs and their most recent common ancestor, before we
print the output.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:nev}>>=
  func mrca(w http.ResponseWriter, r *http.Request, p *PageData) {
	  taxa := getTaxa(w, r)
	  mrca, err := neidb.MRCA(taxa)
	  util.CheckHTTP(w, err)
	  out := Taxid{mrca}
	  //<<Print output, Pr. \ref{pr:nev}>>
  }
#+end_src
#+begin_export latex
We register \ty{mrca}.
#+end_export
#+begin_src go <<Access \ty{tdb} functions, Pr. \ref{pr:nev}>>=
  http.HandleFunc("/mrca/", makeHandler(mrca))
#+end_src
#+begin_export latex
We also add \ty{mrca} to our list of services.
#+end_export
#+begin_src go <<Add services, Pr. \ref{pr:nev}>>=
  query = "?t=9606,741158,63221"
  service = Service{Name: "mrca",
	  Query: query}
  services = append(services, service)
#+end_src
#+begin_export latex
\subsubsection{\ty{levels}}
The service \ty{levels} takes a s argument a list of genome accessions
and returns their assembly levels. We store the assembly level in a
struct that wraps an accession/level pair.
#+end_export
#+begin_src go <<Types, Pr. \ref{pr:nev}>>=
  type Level struct {
	  Accession string `json:"accession"`
	  Level string `json:"level"`
  }
#+end_src
#+begin_export latex
In our implementation \ty{level} we extract the accession, get its
level and print the output.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:nev}>>=
  func levels(w http.ResponseWriter, r *http.Request, p *PageData) {
	  accessions := getAccessions(w, r)
	  out := []Level{}
	  for _, accession := range accessions {
		  level, err := neidb.Level(accession)
		  util.CheckHTTP(w, err)
		  o := Level{Accession: accession, Level: level}
		  out = append(out, o)
	  }
	  //<<Print output, Pr. \ref{pr:nev}>>
  }
#+end_src
#+begin_export latex
CONT
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:nev}>>=
  func getAccessions(w http.ResponseWriter, r *http.Request) []string {
	  accessions := []string{}
	  a := r.URL.Query().Get("a")
	  accs := strings.Split(a, ",")
	  for _, accession := range accs {
		  accessions = append(accessions, accession)
	  }
	  return accessions
  }
#+end_src
#+begin_export latex
We register \ty{levels}.
#+end_export
#+begin_src go <<Access \ty{tdb} functions, Pr. \ref{pr:nev}>>=
  http.HandleFunc("/levels/", makeHandler(levels))
#+end_src
#+begin_export latex
We also add \ty{levels} to our list of services.
#+end_export
#+begin_src go <<Add services, Pr. \ref{pr:nev}>>=
  query = "?a=GCF_000001405.40,GCA_000002115.2"
  service = Service{Name: "levels",
	  Query: query}
  services = append(services, service)
#+end_src
#+begin_export latex
\subsection{Start Server}
We have built the server, now we can start it. If the user supplied a
pair of encryption keys, we start it as a HTTPS server, otherwise its
a HTTP server.
#+end_export
#+begin_src go <<Start server, Pr. \ref{pr:nev}>>=
  host := *flagO + ":" + *flagP
  if *flagC != "" && *flagK != "" {
	  log.Fatal(http.ListenAndServeTLS(host, *flagC,
		  ,*flagK, nil))
  } else {
	  log.Fatal(http.ListenAndServe(host, nil))
  }
#+end_src
