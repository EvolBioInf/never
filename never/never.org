#+begin_export latex
The program \ty{never} is a webserver that provides access to the
facilities of the Neighbors package; hence the name \emph{Neighbors
Sever}, or \ty{never}.

Our outline of \ty{never} contains hooks for imports, types,
variables, functions, and the logic of the main
function.\bpr{never}{pr:nev}
#+end_export
#+begin_src go <<never.go>>=
  package main

  import (
	  //<<Imports, Pr. \ref{pr:nev}>>
  )
  //<<Types, Pr. \ref{pr:nev}>>
  //<<Variables, Pr. \ref{pr:nev}>>
  //<<Functions, Pr. \ref{pr:nev}>>
  func main() {
	  //<<Main function, Pr. \ref{pr:nev}>>
  }
#+end_src
#+begin_export latex
\epr In the main function we prepare logging, before we construct the
server and start it.
#+end_export
#+begin_src go <<Main function, Pr. \ref{pr:nev}>>=
  util.PrepLog("never")
  //<<Construct server, Pr. \ref{pr:nev}>>
  //<<Start server, Pr. \ref{pr:nev}>>
#+end_src
#+begin_export latex
We import \ty{util}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:nev}>>=
  "github.com/evolbioinf/never/util"
#+end_src
#+begin_export latex
Our web server, like any web server, consists of two parts, a front
end and a back end. The front end consists of the things seen by the
user via a browser. This often consists of web pages, but may be as
light weight as a URL extended by a query.

The back end consists of a command-line program seen by the sysadmin
who starts the server. The back end is easier to write than the front
end, so we begin with it.
#+end_export
#+begin_src go <<Construct server, Pr. \ref{pr:nev}>>=
  //<<Construct back end, Pr. \ref{pr:nev}>>
  //<<Construct front end, Pr. \ref{pr:nev}>>
#+end_src
#+begin_export latex
  \section{Back End}
  In the back end we declare the flags, set the usage, parse the
  flags, and respond to them.
#+end_export
#+begin_src go <<Construct back end, Pr. \ref{pr:nev}>>=
  //<<Declare flags, Pr. \ref{pr:nev}>>
  //<<Set usage, Pr. \ref{pr:nev}>>
  flag.Parse()
  //<<Respond to flags, Pr. \ref{pr:nev}>>
#+end_src
#+begin_export latex
  We import \ty{flag}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:nev}>>=
  "flag"
#+end_src
#+begin_export latex
The server has a version flag (\ty{-v}). It runs on a host (\ty{-o}),
where it listens at a port (\ty{-p}). In addition, it may require a
pair of public (\ty{-c}) and private keys (\ty{-k}) to run. A public
key is also known as a \emph{certificate}, hence the \ty{-c} flag. The
program \ty{never} accesses a database (\ty{-d}), either via one of
the Neighbors program or directly. This database has been last updated
at a time recorded in a file given via \ty{-u}.
#+end_export
#+begin_src go <<Declare flags, Pr. \ref{pr:nev}>>=
  flagV := flag.Bool("v", false, "version")
  flagO := flag.String("o", "localhost", "host")
  flagP := flag.String("p", "443", "port")
  flagC := flag.String("c", "", "certificate")
  flagK := flag.String("k", "", "private key")
  flagD := flag.String("d", "neidb", "database")
  flagU := flag.String("u", "updated.txt", "last updated")
#+end_src
#+begin_export latex
The usage consists of the actual usage message, an explanation of the
purpose of \ty{never}, and an example command.
#+end_export
#+begin_src go <<Set usage, Pr. \ref{pr:nev}>>=
  u := "never [flag]..."
  p := "The program never is a web server " +
	  "providing a REST API for the Neighbors package."
  e := "never -o 10.254.1.21 -c Cert_bundle.pem -k privateKey.pem"
  clio.Usage(u, p, e)
#+end_src
#+begin_export latex
  We import \ty{clio}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:nev}>>=
  "github.com/evolbioinf/clio"
#+end_src
#+begin_export latex
We respond to the version flag, \ty{-v}, the host (\ty{-o}) and port
(\ty{-p}) flags, the database flag, \ty{-d}, and the updated flag,
\ty{-u}.
#+end_export
#+begin_src go <<Respond to flags, Pr. \ref{pr:nev}>>=
  //<<Respond to \ty{-v}, Pr. \ref{pr:nev}>>
  //<<Respond to \ty{-o} and \ty{-p}, Pr. \ref{pr:nev}>>
  //<<Respond to \ty{-d}, Pr. \ref{pr:nev}>>
  //<<Respond to \ty{-u}, Pr. \ref{pr:nev}>>
#+end_src
#+begin_export latex
If the user asked for the version, we print the program information,
which includes the version.
#+end_export
#+begin_src go <<Respond to \ty{-v}, Pr. \ref{pr:nev}>>=
  if *flagV {
	  util.PrintInfo()
  }
#+end_src
#+begin_export latex
We make host and port global variables for easy access from within the
HTTP handler functions we write later on.
#+end_export
#+begin_src go <<Variables, Pr. \ref{pr:nev}>>=
  var host, port string
#+end_src
#+begin_export latex
We assign the host and port flags to their global counterparts.
#+end_export
#+begin_src go <<Respond to \ty{-o} and \ty{-p}, Pr. \ref{pr:nev}>>=
  host = *flagO
  port = *flagP
#+end_src
#+begin_export latex
In response to the database flag, we open the database. This
precipitates a fatal error if the database does not exist.
#+end_export
#+begin_src go <<Respond to \ty{-d}, Pr. \ref{pr:nev}>>=
  neidb = tdb.OpenTaxonomyDB(*flagD)
#+end_src
#+begin_export latex
We declare the variable \ty{neidb} global to make the database easily
accessible from the various http handlers we shall write.
#+end_export
#+begin_src go <<Variables, Pr. \ref{pr:nev}>>=
  var neidb *tdb.TaxonomyDB
#+end_src
#+begin_export latex
We import \ty{tdb}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:nev}>>=
  "github.com/evolbioinf/neighbors/tdb"
#+end_src
#+begin_export latex
We respond to the updated flag \ty{-u} by checking the file supplied
actually exists and contains the seven strings that make up the date
generated with the Unix command \ty{date}. If not, we bail. If
everything is ok, we set the name of the file to the global variable
\ty{dateFile} so we can load it whenever the top page of \ty{never} is
called.
#+end_export
#+begin_src go <<Respond to \ty{-u}, Pr. \ref{pr:nev}>>=
  date, err := os.ReadFile(*flagU)
  util.Check(err)
  tmpFields := bytes.Fields(date)
  if len(tmpFields) != 7 {
	  log.Fatalf("%q doesn't look like a date",
		  string(date))
  }
  dateFile = *flagU
#+end_src
#+begin_export latex
We import \ty{os}, \ty{bytes}, and \ty{log}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:nev}>>=
  "os"
  "bytes"
  "log"
#+end_src
#+begin_export latex
We declare \ty{dateFile}.
#+end_export
#+begin_src go <<Variables, Pr. \ref{pr:nev}>>=
  var dateFile string
#+end_src
#+begin_export latex
\section{Front End}
We've finished writing the back end, so we turn to the front end. This
depends on a various files we need to serve first of all. Then we
construct the HTML files that make up the user interface. These are
divided into three categories. First, there is the start, or
\emph{index} page, then there are pages to emulate Neighbors programs,
and finally there are pages giving access to \ty{tdb} functions.
#+end_export
#+begin_src go <<Construct front end, Pr. \ref{pr:nev}>>=
  //<<Serve files, Pr. \ref{pr:nev}>>
  //<<Construct index page, Pr. \ref{pr:nev}>>
  //<<Emulate Neighbors programs, Pr. \ref{pr:nev}>>
  //<<Access \ty{tdb} functions, Pr. \ref{pr:nev}>>
#+end_src
#+begin_export latex
\subsection{Files}
We serve three kinds of files. Style files, the files of the Vitax
interface for visualizing the taxonomy, and data files.
#+end_export
#+begin_src go <<Serve files, Pr. \ref{pr:nev}>>=
  //<<Serve style files, Pr. \ref{pr:nev}>>
  //<<Serve Vitax files, Pr. \ref{pr:nev}>>
  //<<Serve data files, Pr. \ref{pr:nev}>>
#+end_src
#+begin_export latex
The style files are locate in the directory \ty{static}. We make them
available by registering a file server to that directory.
#+end_export
#+begin_src go <<Serve style files, Pr. \ref{pr:nev}>>=
  staticFiles := http.FileServer(http.Dir("static"))
  http.Handle("/static/", http.StripPrefix("/static/", staticFiles))
#+end_src
#+begin_export latex
We import \ty{http}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:nev}>>=
  "net/http"
#+end_src
#+begin_export latex
The Vitax files are located in directory \ty{vitax}. We make them
available by registering a file server to that directory.
#+end_export
#+begin_src go <<Serve Vitax files, Pr. \ref{pr:nev}>>=
  vitaxFiles := http.FileServer(http.Dir("vitax"))
  http.Handle("/vitax/", http.StripPrefix("/vitax/", vitaxFiles))
#+end_src
#+begin_export latex
The data files, finally, are located in the directory \ty{data}. We
make them available by registering a file server to that directory.
#+end_export
#+begin_src go <<Serve data files, Pr. \ref{pr:nev}>>=
  dataFiles := http.FileServer(http.Dir("data"))
  http.Handle("/data/", http.StripPrefix("/data/", dataFiles))
#+end_src
#+begin_export latex
\subsection{Start Page}
HTML pages are written in response to two data sources. The first data
source is the HTTP request sent by the client. We can think of this as
``external'' data. The second data source is ``internal'' data, for
example the page title. The HTTP request is covered by the type
\verb+http.Request+, but the page data is too varied for a standard
type, so we declare the struct \ty{PageData} and add fields to it as
we go along.
#+end_export
#+begin_src go <<Types, Pr. \ref{pr:nev}>>=
  type PageData struct {
	  //<<\ty{PageData} fields, Pr. \ref{pr:nev}>>
  }
#+end_src
#+begin_export latex
We construct the start, or \emph{index}, page using the function
\ty{index}. It takes three arguments, a writer for sending data down
the HTTP channel, a reader for obtaining data from the HTTP channel,
and internal data. We set the page's data and costruct it it by
executing an HTML template we still need to write. We check the error
returned from executing the template.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:nev}>>=
  func index(w http.ResponseWriter, r *http.Request,
	  p *PageData) {
	  //<<Set index page data, Pr. \ref{pr:nev}>>
	  err = templates.ExecuteTemplate(w, "index", p)
	  util.Check(err)
  }
#+end_src
#+begin_export latex
As page data we set the title and the list of services offered. This
list is potentially long, so we sort it. We also set the number of
taxa and genomes, and when the database was last updated.
#+end_export
#+begin_src go <<Set index page data, Pr. \ref{pr:nev}>>=
  p.Title = "Neighbors"
  p.Services = services
  //<<Sort services, Pr. \ref{pr:nev}>>
  //<<Set number of taxa, Pr. \ref{pr:nev}>>
  //<<Set number of genomes, Pr. \ref{pr:nev}>>
  //<<Set database time stamp, Pr. \ref{pr:nev}>>
#+end_src
#+begin_export latex
We set the declare the fields \ty{Services} and \ty{Title} in
``Neighbors''.
#+end_export
#+begin_src go <<\ty{PageData} fields, Pr. \ref{pr:nev}>>=
  Services []Service
  Title string
#+end_src
#+begin_export latex
A service consists of a name and a query.
#+end_export
#+begin_src go <<Types, Pr. \ref{pr:nev}>>=
  type Service struct {
	  Name, Query string
  }
#+end_src
#+begin_export latex
The variable \ty{services} is a global slice of services.
#+end_export
#+begin_src go <<Variables, Pr. \ref{pr:nev}>>=
  var services []Service
#+end_src
#+begin_export latex
We need to fill this slice of services \emph{before} the index page is
constructed for the first time. So we declare an \ty{init} function
with variables for holding a service and a query, and a hook for
adding services.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:nev}>>=
  func init() {
	  var service Service
	  var query string
	  //<<Add services, Pr. \ref{pr:nev}>>
  }
#+end_src
#+begin_export latex
Before exectuing the index template, we sort the services by their
name.
#+end_export
#+begin_src go <<Sort services, Pr. \ref{pr:nev}>>=
  slices.SortFunc(p.Services, func(a, b Service) int {
	  return strings.Compare(a.Name, b.Name)
  })
#+end_src
#+begin_export latex
We import \ty{slices} and \ty{strings}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:nev}>>=
  "slices"
  "strings"
#+end_src
#+begin_export latex
There are roughly three million taxa, so we store them as a string we
have ``humanized'' by inserting commas.
#+end_export
#+begin_src go <<Set number of taxa, Pr. \ref{pr:nev}>>=
  nt, err := neidb.NumTaxa()
  util.Check(err)
  p.Ntaxa = humanize.Comma(int64(nt))
#+end_src
#+begin_export latex
We declare the field \ty{Ntaxa} in our page data.
#+end_export
#+begin_src go <<\ty{PageData} fields, Pr. \ref{pr:nev}>>=
  Ntaxa string
#+end_src
#+begin_export latex
We import \ty{humanize}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:nev}>>=
  "github.com/dustin/go-humanize"
#+end_src
#+begin_export latex
Similarly, there are more than three million genomes distributed over
four assembly levels in the root's recursive genome counts. So we also
store their sum as a humanized string.
#+end_export
#+begin_src go <<Set number of genomes, Pr. \ref{pr:nev}>>=
  ng := 0
  for _, level := range tdb.AssemblyLevels() {
	  n, err := neidb.NumGenomesRec(1, level)
	  util.Check(err)
	  ng += n
  }
  p.Ngenomes = humanize.Comma(int64(ng))
#+end_src
#+begin_export latex
We declare the field \ty{Ngenomes} in our page data.
#+end_export
#+begin_src go <<\ty{PageData} fields, Pr. \ref{pr:nev}>>=
  Ngenomes string
#+end_src
#+begin_export latex
To set the time stamp of the database, we read the content of the date
file, which has the format
\begin{verbatim}
Thu May 22 02:00:01 AM CEST 2025
\end{verbatim}
We reformat this to the more friendly
\begin{verbatim}
May 22 2025 at 02:00:01 AM CEST
\end{verbatim}
#+end_export
#+begin_src go <<Set database time stamp, Pr. \ref{pr:nev}>>=
  date, err := os.ReadFile(dateFile)
  util.Check(err)
  fields := strings.Fields(string(date))
  p.Date = fmt.Sprintf("%s %s %s at %s %s %s",
	  fields[1],
	  fields[2],
	  fields[6],
	  fields[3],
	  fields[4],
	  fields[5])

#+end_src
#+begin_export latex
We declare the field \ty{Date} in our page data.
#+end_export
#+begin_src go <<\ty{PageData} fields, Pr. \ref{pr:nev}>>=
  Date string
#+end_src
#+begin_export latex
We import \ty{fmt}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:nev}>>=
  "fmt"
#+end_src
#+begin_export latex
We also declare and initialize the variable \ty{templates}, which
holds the templates from which we generate the HTML pages.
#+end_export
#+begin_src go <<Variables, Pr. \ref{pr:nev}>>=
  var templates = template.New("templates")
#+end_src
#+begin_export latex
We import \ty{template}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:nev}>>=
  "html/template"
#+end_src
#+begin_export latex
Figure~\ref{fig:idx} is a sketch of the index page. It consists two
main parts, the head and the body, separated by the horizontal
line. The body consists of a title, a description, and a table of the
services accessible via the server. Each row in that table consists of
a number, a name, and an example query presented as a hyperlink.
\begin{figure}
  \input{../never/index}
\caption{Sketch of the index page of \ty{never}.}\label{fig:idx}
\end{figure}
#+end_export
#+begin_export latex
We write all templates to the file \ty{templates.html}. In our first
template, \ty{index}, we call two sub-templates for a generic head and
an index-specific body.
#+end_export
#+begin_src html <<templates.html>>=
  {{define "index"}}
  <!DOCTYPE html>
  <html lang="en">
    <head>
      {{template "head" .}}
    </head>
    <body>
      {{template "indexBody" .}}
    </body>
  </html>
  {{end}}
#+end_src
#+begin_export latex
In the head template we set the character set, the page layout, and
the location of the style file. Then we set the page title.
#+end_export
#+begin_src html <<templates.html>>=
  {{define "head"}}
  <meta charset="UTF-8"/>
  <meta name="viewport"
	content="width=device-width,initial-scale=1.0"/>
  <link rel="stylesheet" href="./static/w3.css"/>
  <title>{{.Title}}</title>
  {{end}}
#+end_src
#+begin_export latex
In the body template we call threed sub-templates for the title, the
description and the list of services.
#+end_export
#+begin_src html <<templates.html>>=
  {{define "indexBody"}}
  {{template "indexTitle"}}
  {{template "indexDescr" .}}
  {{template "services" .Services}}
  {{end}}
#+end_src
#+begin_export latex
We set the title.
#+end_export
#+begin_src html <<templates.html>>=
  {{define "indexTitle"}}
  <div class="w3-container">
    <h1>Welcome to the Neighbors REST API</h1>
  </div>
  {{end}}
#+end_src
#+begin_export latex
We introduce our server, describe the Neighbor method, and give some
background to it. We also quote the number of taxa and genomes in the
database, and when it was last updated.
#+end_export
#+begin_src html <<templates.html>>=
  {{define "indexDescr"}}
  <div class="w3-container">
    //<<Introduce the Neighbors server, Pr. \ref{pr:nev}>>
    //<<Describe the Neighbors method, Pr. \ref{pr:nev}>>
    //<<Give some background to Neighbors, Pr. \ref{pr:nev}>>
    //<<Print number of taxa and genomes in database, Pr. \ref{pr:nev}>>
    //<<Print when database was last updated, Pr. \ref{pr:nev}>>	
   </div>
  {{end}}
#+end_src
#+begin_export latex
We give a quick introduction to the Neighbors server.
#+end_export
#+begin_src html <<Introduce the Neighbors server, Pr. \ref{pr:nev}>>=
  <p>
    The Neighbors REST API gives access to genome sequences via
    the taxonomy of sequenced life.
  </p>
#+end_src
#+begin_export latex
We describe the Neighbors method of comparative marker discovery.
#+end_export
#+begin_src html <<Describe the Neighbors method, Pr. \ref{pr:nev}>>=
  <p>
    Starting from one or more target organisms, the accessions of
    their genomes can be looked up. In addition, the genome
    accessions of the targets' closest relatives, their
    <i>neighbors</i>, can be looked up. Such pairs of samples of
    target and neighbor genomes make good starting material for
    developing diagnostic markers.
  </p>
#+end_src
#+begin_export latex
As background, we list our data sources, credit the authors of the
server, and quote the pertient paper.
#+end_export
#+begin_src html <<Give some background to Neighbors, Pr. \ref{pr:nev}>>=
  <p>
    //<<List data sources, Pr. \ref{pr:nev}>>
    //<<Give credit for server, Pr. \ref{pr:nev}>>
    //<<Quote paper, Pr. \ref{pr:nev}>>
  </p>
#+end_src
#+begin_export latex
We list the NCBI as the source of our raw data. And link to a package
from which the current database was built.
#+end_export
#+begin_src html <<List data sources, Pr. \ref{pr:nev}>>=
  We use the <a href="https://ftp.ncbi.nlm.nih.gov/pub/taxonomy/">
  taxonomy</a>
  and <a href="https://ftp.ncbi.nlm.nih.gov/genomes/ASSEMBLY_REPORTS">
  genome data</a> supplied by
  the <a href="https://www.ncbi.nlm.nih.gov/">NCBI</a> to build a custom
  database. The compressed files we used for the construction of the
  current database can be downloaded
  from <a href="https://neighbors.evolbio.mpg.de/data/neidbData.tgz">here</a>,
  the much larger sqlite database itself
  is <a href="https://neighbors.evolbio.mpg.de/data/neidb">here</a>.
#+end_src
#+begin_export latex
Our server is a group effort, as is the underlying Neighbors package.
#+end_export
#+begin_src html <<Give credit for server, Pr. \ref{pr:nev}>>=
  Our REST API for querying this database is developed by
  the <a href="https://evolbioinf.github.io/">Research Group
  Bioinformatics</a> at
  the <a href="https://evolbio.mpg.de">Max-Planck-Institute for
  Evolutionary Biology</a> using
  our <a href="https://github.com/evolbioinf/neighbors">
    Neighbors</a> package.
#+end_src
#+begin_export latex
We quote our paper on marker discovery in the large~\cite{vie24:mar}.
#+end_export
#+begin_src html <<Quote paper, Pr. \ref{pr:nev}>>=
  For more details on genetic marker discovery from whole genome
  sequences with Neighbors and related software, please read
  our <a href="https://doi.org/10.1093/bioadv/vbae113">
    publication</a>.
#+end_src
#+begin_export latex
We get the number of taxa and genomes in a table.
#+end_export
#+begin_src html <<Print number of taxa and genomes in database, Pr. \ref{pr:nev}>>=
  <p>
    <table>
      <tr>
	<td>Number of taxa</td>
	<td>{{.Ntaxa}}</td>
      </tr>
      <tr>
	<td>Number of genomes</td>
	<td>{{.Ngenomes}}</td>
      </tr>
    </table>
  </p>
#+end_src
#+begin_export latex
We print the database time stamp.
#+end_export
#+begin_src go <<Print when database was last updated, Pr. \ref{pr:nev}>>=
  <p>
	  The database was last updated on {{.Date}}.
  </p>
#+end_src
#+begin_export latex
We define the template for printing the services, which calls a
template for printing a table.
#+end_export
#+begin_src html <<templates.html>>=
  {{define "services"}}
  <div class="w3-container">
    <h2>Services</h2>
    <table class="w3-container">
      {{template "table" .}}
    </table>
  </div>
  {{end}}
#+end_src
#+begin_export latex
The table consists of a header and a body.
#+end_export
#+begin_src html <<templates.html>>=
  {{define "table"}}
  {{template "header"}}
  {{template "body" .}}
  {{end}}
#+end_src
#+begin_export latex
In the header we label the three columns enumerator, name, and query.
#+end_export
#+begin_src html <<templates.html>>=
  {{define "header"}}
  <tr>
    <th>#</th>
    <th>Name</th>
    <th>Query</th>
  </tr>
  {{end}}
#+end_src
#+begin_export latex
To write the body of the table, we iterate over its rows and write the
enumerator, name, and query as sketched in Figure~\ref{fig:idx}. The
enumerator is calculated by incrementing the current index with the
function \ty{inc}.
#+end_export
#+begin_src html <<templates.html>>=
  {{define "body"}}
  {{range $i, $e := .}}
  <tr>
    <td>{{inc $i}}</td>
    <td>{{.Name}}</td>
    <td><a href="{{.Name}}{{.Query}}"><code>{{.Query}}</code></td>
  </tr>
  {{end}}
  {{end}}
#+end_src
#+begin_export latex
The function \ty{inc} increments its argument.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:nev}>>=
  func inc(i int) int {
	  return i + 1
  }
#+end_src
#+begin_export latex
In order to associate \ty{inc} with our templates, we create a
function map.
#+end_export
#+begin_src go <<Variables, Pr. \ref{pr:nev}>>=
  var templateFuncs = make(template.FuncMap)
#+end_src
#+begin_export latex
Like the slice of services, the function map needs to be filled with
the associated functions and added to the our collection of templates
before we use any of them. To ensure this, we declare an \ty{init}
function, in which we add the template functions to their map and then
add the map to the templates. Having added the functions to the
templates, we can carry out the initial parsing of the templates. We
have written these to the file \ty{templates.html}, which we keep in
the directory \ty{static}.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:nev}>>=
  func init() {
	  //<<Add template functions, Pr. \ref{pr:nev}>>
	  templates = templates.Funcs(templateFuncs)
	  path := "./static/templates.html"
	  templates = template.Must(templates.ParseFiles(path))
  }
#+end_src
#+begin_export latex
We add the template function \ty{inc}.
#+end_export
#+begin_src go <<Add template functions, Pr. \ref{pr:nev}>>=
  templateFuncs["inc"] = inc
#+end_src
#+begin_export latex
We have now written the index page, but still need to register it as
the handler for a given pattern. However, we can only register
functions of type \ty{HandlerFunc}. These have two arguments, a
response writer and a request, while \ty{index} has three arguments,
writer, request, and page data. So we convert \ty{index} to a handler
function using a dedicated function, \ty{makeHandler}.

Our function \ty{makeHandler} takes as argument an ordinary function
with three arguments, writer, reader, and data. It generates a new
variable for holding the page data and returns a handler
function. Inside that handler function we set the writer such that it
allows access from all domains. Then we call the ordinary function
passed with the reader, the adjusted writer, and the new page data as
arguments.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:nev}>>=
  func makeHandler(fn func(http.ResponseWriter, *http.Request,
	  ,*PageData)) http.HandlerFunc {
	  p := new(PageData)
	  return func(w http.ResponseWriter, r *http.Request) {
		  w.Header().Set("Access-Control-Allow-Origin",
			  "*")
		  fn(w, r, p)
	  }
  }
#+end_src
#+begin_export latex
We register \ty{index} as the function that handles calls to the root
of our web site.
#+end_export
#+begin_src go <<Construct index page, Pr. \ref{pr:nev}>>=
  http.HandleFunc("/", makeHandler(index))
#+end_src
#+begin_export latex
\subsection{\ty{taxi}}
The service \ty{taxi} takes as input the name of a taxon, a matching
mode, a page number, and a page size. It writes as response for each
matching taxon the taxon ID, its parent's taxon ID, and its scientific
name. To store these three items, we declare the \ty{struct}
\ty{Taxon}.
#+end_export
#+begin_src go <<Types, Pr. \ref{pr:nev}>>=
  type Taxon struct {
	  Taxid int `json:"taxid"`
	  Parent int `json:"parent"`
	  Name string `json:"name"`
	  CommonName string `json:"common_name"`
  }
#+end_src
#+begin_export latex
We write \ty{taxi} on the same pattern as \ty{index}.  Inside
\ty{taxi}, we extract the query from the HTTP request, query the
database, and write the result to the HTTP writer.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:nev}>>=
  func taxi(w http.ResponseWriter, r *http.Request, p *PageData) {
	  //<<Extract taxi query, Pr. \ref{pr:nev}>>
	  //<<Execute taxi query, Pr. \ref{pr:nev}>>
	  //<<Print taxi result, Pr. \ref{pr:nev}>>
  }
#+end_src
#+begin_export latex
We extract the taxon name, whether or not we are matching in exact
mode, the page, and the page size. If we are \emph{not} matching in
exact mode, we bracket the name and the blanks it contains by wild
cards.
#+end_export
#+begin_src go <<Extract taxi query, Pr. \ref{pr:nev}>>=
  name := r.URL.Query().Get("t")
  sstr := r.URL.Query().Get("e")
  page := r.URL.Query().Get("p")
  size := r.URL.Query().Get("n")
  if sstr != "1" && len(name) > 0 {
	  name = strings.ReplaceAll(name, " ", "% %")
	  name = "%" + name + "%"
  }
#+end_src
#+begin_export latex
The taxi query requires limit and offset as integers instead of the
given page and page size as strings. So we calculate these two
quantities before we execute the query in two phases. First, we get
the matching taxon IDs. Then we iterate over the taxon IDs and for
each one construct the taxon output and store it in our slice of
taxa.
#+end_export
#+begin_src go <<Execute taxi query, Pr. \ref{pr:nev}>>=
  var limit, offset int
  //<<Convert page size to limit, Pr. \ref{pr:nev}>>
  //<<Calculate offset, Pr. \ref{pr:nev}>>
  ids, err := neidb.Taxids(name, limit, offset)
  util.Check(err)
  out := []Taxon{}
  for _, id := range ids {
	  //<<Construct taxon output, Pr. \ref{pr:nev}>>
	  //<<Store taxon output, Pr. \ref{pr:nev}>>
  }
#+end_src
#+begin_export latex
We convert the string holding the page size to the desired integer
limit on the number of results returned.
#+end_export
#+begin_src go <<Convert page size to limit, Pr. \ref{pr:nev}>>=
  limit, err := strconv.Atoi(size)
  if err != nil {
	  limit = 0
  }
#+end_src
#+begin_export latex
We import \ty{strconv}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:nev}>>=
  "strconv"
#+end_src
#+begin_export latex
The offset is the pages number minus 1 times the page size.
#+end_export
#+begin_src go <<Calculate offset, Pr. \ref{pr:nev}>>=
  pageNum, err := strconv.Atoi(page)
  if err != nil {
	  pageNum = 1
  }
  offset = (pageNum-1) * limit
#+end_src
#+begin_export latex
We get the taxon's scientific and common names and parent. Then we
construct the corresponding taxon output.
#+end_export
#+begin_src go <<Construct taxon output, Pr. \ref{pr:nev}>>=
  sciName, err := neidb.Name(id)
  util.Check(err)
  comName, err := neidb.CommonName(id)
  util.Check(err)
  tout := Taxon{}
  parent, err := neidb.Parent(id)
  if err == nil {
	  tout = Taxon{Taxid: id, Parent: parent,
		  Name: sciName, CommonName: comName}
  }
#+end_src
#+begin_export latex
If we just constructed an output item, we store it in the
corresponding slice.
#+end_export
#+begin_src go <<Store taxon output, Pr. \ref{pr:nev}>>=
  if err == nil {
	  out = append(out, tout)
  }
#+end_src
#+begin_export latex
We convert the slice of taxi output to JSON format and write it to the
response writer.
#+end_export
#+begin_src go <<Print taxi result, Pr. \ref{pr:nev}>>=
  b, err := json.MarshalIndent(out, "", "    ")
  util.Check(err)
  fmt.Fprintf(w, "%s\n", string(b))
#+end_src
#+begin_export latex
We import \ty{json}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:nev}>>=
  "encoding/json"
  "fmt"
#+end_src
#+begin_export latex
We can now emulate the \ty{taxi} program by registering the service
\ty{taxi} to the URL \verb+/taxi/+.
#+end_export
#+begin_src go <<Emulate Neighbors programs, Pr. \ref{pr:nev}>>=
  http.HandleFunc("/taxi/", makeHandler(taxi))
#+end_src
#+begin_export latex
We also add the \ty{taxi} service to our list of services. Our example
query simulates a user typing \emph{E} for \emph{Escherichia coli} and
getting a second page of no more than 10 results.
#+end_export
#+begin_src go <<Add services, Pr. \ref{pr:nev}>>=
  query = "?t=E&n=10&p=2"
  service = Service{Name: "taxi", Query: query}
  services = append(services, service)
#+end_src
#+begin_export latex
\subsection{\ty{accessions}}
The service \ty{accessions} takes as argument one or more taxon IDs
and returns the genome accessions in the clades rooted on them,
indexed by taxon ID. We store individual accessions in the type
\ty{Accession}, which wraps an accession and an assembly level.
#+end_export
#+begin_src go <<Types, Pr. \ref{pr:nev}>>=
  type Accession struct {
	  Accession string `json:"accession"`
	  Level string `json:"level"`
  }
#+end_src
#+begin_export latex
The output of our service is a slice of type \ty{Accessions}, which
consists of a taxon ID and a slice of the accessions that belong to
it.
#+end_export
#+begin_src go <<Types, Pr. \ref{pr:nev}>>=
  type Accessions struct {
	  Taxid int `json:"taxid"`
	  Accs []Accession `json:"accessions"`
  }
#+end_src
#+begin_export latex
We implement the service in the function \ty{accessions}. Inside of
\ty{accessions}, we get the taxa through a call to \ty{getTaxa}, which
we still need to implement. Then we get the corresponding accessions,
before we print the output.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:nev}>>=
  func accessions(w http.ResponseWriter, r *http.Request,
	  p *PageData) {
	  taxa := getTaxa(w, r)
	  //<<Get accessions, Pr. \ref{pr:nev}>>
	  //<<Print output, Pr. \ref{pr:nev}>>
  }
#+end_src
#+begin_export latex
The function \ty{getTaxa} takes as input a HTTP request, stores the
taxa passed, and returns them. The taxa arrive
as the value of key \ty{t}.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:nev}>>=
  func getTaxa(w http.ResponseWriter, r *http.Request) []int {
	  taxa := []int{}
	  t := r.URL.Query().Get("t")
	  //<<Store taxa, Pr. \ref{pr:nev}>>
	  return taxa
  }
#+end_src
#+begin_export latex
The taxa are comma delimited so we split the taxon string at the
commas and iterate over the resulting tokens to convert each one into
a taxon. We check the existence of the taxon before we append it to
the slice of taxa.
#+end_export
#+begin_src go <<Store taxa, Pr. \ref{pr:nev}>>=
  tokens := strings.Split(t, ",")
  for _, token := range tokens {
	  taxon := 0
	  //<<Convert token to taxon, Pr. \ref{pr:nev}>>
	  //<<Check existence of taxon, Pr. \ref{pr:nev}>>
	  taxa = append(taxa, taxon)
  }
#+end_src
#+begin_export latex
We convert the string token into an integer. If this fails, we skip
the rest of the loop.
#+end_export
#+begin_src go <<Convert token to taxon, Pr. \ref{pr:nev}>>=
  taxon, err := strconv.Atoi(token)
  if err != nil {
	  continue
  }
#+end_src
#+begin_export latex
If the taxon has no name, it doesn't exist and we also skip the rest
of the loop.
#+end_export
#+begin_src go <<Check existence of taxon, Pr. \ref{pr:nev}>>=
  _, err = neidb.Name(taxon)
  if err != nil {
	  continue
  }
#+end_src
#+begin_export latex
We declare a slice of accessions for storing them. Then we iterate for
as long as our slice of taxa isn't empty. Inside the loop we remove
the first taxon from the slice and look up its accessions. If we get
at least one, we store it. Then we get the taxon's children.
#+end_export
#+begin_src go <<Get accessions, Pr. \ref{pr:nev}>>=
  out := []Accessions{}
  for len(taxa) > 0 {
	  taxid := taxa[0]
	  taxa = taxa[1:]
	  accs, err := neidb.Accessions(taxid)
	  util.Check(err)
	  if len(accs) > 0 {
		  //<<Store accessions, Pr. \ref{pr:nev}>>
	  }
	  //<<Get children, Pr. \ref{pr:nev}>>
  }
#+end_src
#+begin_export latex
We make a variable of type \ty{Accessions} based on the taxid and
store it in our output slice. Then we complete the accessions by
adding their levels before storing them.
#+end_export
#+begin_src go <<Store accessions, Pr. \ref{pr:nev}>>=
  o := Accessions{Taxid: taxid}
  for _, acc := range accs {
	  level, err := neidb.Level(acc)
	  util.Check(err)
	  accession := Accession{Accession: acc, Level: level}
	  o.Accs = append(o.Accs, accession)
  }
  out = append(out, o)
#+end_src
#+begin_export latex
We retrieve the children of the current taxon and store them in our
slice of taxa, ready for the next iteration.
#+end_export
#+begin_src go <<Get children, Pr. \ref{pr:nev}>>=
  children, err := neidb.Children(taxid)
  for _, child := range children {
	  taxa = append(taxa, child)
  }
#+end_src
#+begin_export latex
We convert our slice of accessions items to JSON and print it as our
response.
#+end_export
#+begin_src go <<Print output, Pr. \ref{pr:nev}>>=
  b, err := json.MarshalIndent(out, "", "    ")
  util.Check(err)
  fmt.Fprintf(w, "%s\n", string(b))
#+end_src
#+begin_export latex
We are done writing \ty{accessions}. So we convert it to a handler
function and register it.
#+end_export
#+begin_src go <<Access \ty{tdb} functions, Pr. \ref{pr:nev}>>=
  http.HandleFunc("/accessions/", makeHandler(accessions))
#+end_src
#+begin_export latex
We also add \ty{accessions} to our list of services. We use
\emph{Mesorhizobiom ciceri biovar biserrulae} (taxid 278148) as
example, because it is small and illustrates the recursive nature of
\ty{accessions}.
#+end_export
#+begin_src go <<Add services, Pr. \ref{pr:nev}>>=
  query = "?t=9606"
  service = Service{Name: "accessions",
	  Query: query}
  services = append(services, service)
#+end_src
#+begin_export latex
\subsection{\ty{names}}
The service \ty{names} takes a as argument a list of taxon IDs and
returns their scientific and common names. We store its output in the struct
\ty{Name}, which wraps a taxid/name pair.
#+end_export
#+begin_src go <<Types, Pr. \ref{pr:nev}>>=
  type Name struct {
	  Taxid int `json:"taxid"`
	  Name string `json:"name"`
	  CommonName string `json:"common_name"`
  }
#+end_src
#+begin_export latex
The query is implemented in the service \ty{names}. Inside \ty{names},
we iterate over the taxon IDs and find their names before we print the
output.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:nev}>>=
  func names(w http.ResponseWriter, r *http.Request,
	  p *PageData) {
	  taxa := getTaxa(w, r)
	  out := []Name{}
	  for i, taxon := range taxa {
		  //<<Find name, Pr. \ref{pr:nev}>>
	  }
	  //<<Print output, Pr. \ref{pr:nev}>>
  }
#+end_src
#+begin_export latex
We look up the taxon's name and store it.
#+end_export
#+begin_src go <<Find name, Pr. \ref{pr:nev}>>=
  name, err := neidb.Name(taxon)
  util.Check(err)
  cname, err := neidb.CommonName(taxon)
  util.Check(err)
  o := Name{Taxid: taxa[i], Name: name,
	  CommonName: cname}
  out = append(out, o)
#+end_src
#+begin_export latex
We convert \ty{names} to a handler function and register it.
#+end_export
#+begin_src go <<Access \ty{tdb} functions, Pr. \ref{pr:nev}>>=
  http.HandleFunc("/names/", makeHandler(names))
#+end_src
#+begin_export latex
We also add \ty{names} to our list of services.
#+end_export
#+begin_src go <<Add services, Pr. \ref{pr:nev}>>=
  query = "?t=9606,9605"
  service = Service{Name: "names",
	  Query: query}
  services = append(services, service)
#+end_src
#+begin_export latex
\subsection{\ty{ranks}}
The service \ty{ranks} takes as argument a list of taxon IDs and
returns their ranks. We store the output in a slice with elements of
type \ty{Rank}, which wraps a taxid/rank pair.
#+end_export
#+begin_src go <<Types, Pr. \ref{pr:nev}>>=
  type Rank struct {
	  Taxid int `json:"taxid"`
	  Rank string `json:"rank"`
  }
#+end_src
#+begin_export latex
In the function \ty{ranks} we get the taxon IDs, query and store the
corresponding ranks, and print the output.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:nev}>>=
  func ranks(w http.ResponseWriter, r *http.Request,
	  p *PageData) {
	  taxa := getTaxa(w, r)
	  out := []Rank{}
	  for i, taxon := range taxa {
		  rank, err := neidb.Rank(taxon)
		  util.Check(err)
		  o := Rank{Taxid: taxa[i], Rank: rank}

		  out = append(out, o)
	  }
	  //<<Print output, Pr. \ref{pr:nev}>>
  }
#+end_src
#+begin_export latex
We convert \ty{ranks} to a handler function and register it.
#+end_export
#+begin_src go <<Access \ty{tdb} functions, Pr. \ref{pr:nev}>>=
  http.HandleFunc("/ranks/", makeHandler(ranks))
#+end_src
#+begin_export latex
We also add \ty{ranks} to our list of services.
#+end_export
#+begin_src go <<Add services, Pr. \ref{pr:nev}>>=
  query = "?t=9606,9605"
  service = Service{Name: "ranks",
	  Query: query}
  services = append(services, service)
#+end_src
#+begin_export latex
\subsection{\ty{parent}}
The service \ty{parent} takes as argument a taxon ID and returns the
parent's taxon ID. We store its output in a \ty{struct} that wraps a
single taxon ID, or taxid.
#+end_export
#+begin_src go <<Types, Pr. \ref{pr:nev}>>=
  type Taxid struct {
	  Taxid int `json:"taxid"`
  }
#+end_src
#+begin_export latex
In the function \ty{parent} we get the taxon ID, look up the parent,
and print the output. If we cannot find a parent, we return zero as
parent.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:nev}>>=
  func parent(w http.ResponseWriter, r *http.Request,
	  p *PageData) {
	  //<<Get taxid, Pr. \ref{pr:nev}>>
	  parent, err := neidb.Parent(taxid)
	  out := Taxid{0}
	  if err == nil {
		  out = Taxid{parent}
	  }
	  //<<Print output, Pr. \ref{pr:nev}>>
  }
#+end_src
#+begin_export latex
We get the taxon ID through a call to the function \ty{getTaxa}. If
\ty{getTaxa} returns no taxa, we set the taxon ID to the non-existent
taxid zero.
#+end_export
#+begin_src go <<Get taxid, Pr. \ref{pr:nev}>>=
  taxa := getTaxa(w, r)
  taxid := 0
  if len(taxa) > 0 {
	  taxid = taxa[0]
  }
#+end_src
#+begin_export latex
We register \ty{parent}.
#+end_export
#+begin_src go <<Access \ty{tdb} functions, Pr. \ref{pr:nev}>>=
  http.HandleFunc("/parent/", makeHandler(parent))
#+end_src
#+begin_export latex
We also add \ty{parent} to our list of services.
#+end_export
#+begin_src go <<Add services, Pr. \ref{pr:nev}>>=
  query = "?t=9606"
  service = Service{Name: "parent",
	  Query: query}
  services = append(services, service)
#+end_src
#+begin_export latex
\subsection{\ty{children}}
The service \ty{children} takes as argument a taxon ID and returns its
children as a slice of their taxon IDs. A child is stored in a
structure that holds its taxon ID and its name.
#+end_export
#+begin_src go <<Types, Pr. \ref{pr:nev}>>=
  type Child struct {
	  Taxid int `json:"taxid"`
	  Name string `json:"name"`
	  CommonName string `json:"common_name"`
  }
#+end_src
#+begin_export latex
We implement the service \ty{children} in the function \ty{children},
where we get the taxon ID and the corresponding children. Then we
iterate over the children and construct the output object for each
one, before we print the output.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:nev}>>=
  func children(w http.ResponseWriter, r *http.Request,
	  p *PageData) {
	  //<<Get taxid, Pr. \ref{pr:nev}>>
	  children, err := neidb.Children(taxid)
	  util.Check(err)
	  out := []Child{}
	  for _, child := range children {
		  //<<Construct child, Pr. \ref{pr:nev}>>
	  }
	  //<<Print output, Pr. \ref{pr:nev}>>
  }
#+end_src
#+begin_export latex
We construct the child from its taxon ID and its names.
#+end_export
#+begin_src go <<Construct child, Pr. \ref{pr:nev}>>=
  name, err := neidb.Name(child)
  util.Check(err)
  cname, err := neidb.CommonName(child)
  util.Check(err)
  o := Child{child, name, cname}
  out = append(out, o)
#+end_src
#+begin_export latex
We register \ty{children}.
#+end_export
#+begin_src go <<Access \ty{tdb} functions, Pr. \ref{pr:nev}>>=
  http.HandleFunc("/children/", makeHandler(children))
#+end_src
#+begin_export latex
We also add \ty{children} to our list of services.
#+end_export
#+begin_src go <<Add services, Pr. \ref{pr:nev}>>=
  query = "?t=9606"
  service = Service{Name: "children",
	  Query: query}
  services = append(services, service)
#+end_src
#+begin_export latex
\subsection{\ty{subtree}}
The service \ty{subtree} returns all taxa in a subtree, including the
root. In the function \ty{subtree} we get the taxon ID, get and store
the corresponding subtree, and print the output. A subtree consists of
nodes, which are structs to hold a taxon ID, its name, its common
name, and the parent ID.
#+end_export
#+begin_src go <<Types, Pr. \ref{pr:nev}>>=
  type Node struct {
	  Taxid int `json:"taxid"`
	  Name string `json:"name"`
	  CommonName string `json:"common_name"`
	  Parent int `json:"parent"`
  }
#+end_src
#+begin_src go <<Functions, Pr. \ref{pr:nev}>>=
  func subtree(w http.ResponseWriter, r *http.Request,
	  p *PageData) {
	  //<<Get taxa in subtree, Pr. \ref{pr:nev}>>
	  //<<Construct nodes in subtree, Pr. \ref{pr:nev}>>
	  //<<Print output, Pr. \ref{pr:nev}>>
  }
#+end_src
#+begin_export latex
We extract the taxon $t$ from the query and obtain the taxa in the
subtree rooted on $t$.
#+end_export
#+begin_src go <<Get taxa in subtree, Pr. \ref{pr:nev}>>=
  //<<Get taxid, Pr. \ref{pr:nev}>>
  taxa, err := neidb.Subtree(taxid)
  util.Check(err)
#+end_src
#+begin_export latex
We iterate over the taxa in the subtree and look up the parent for
each one, except for the root, \ty{taxid}, whose parent is
itself. From the current taxon, its parent, and its names we construct
the new node, which we store in our output slice.
#+end_export
#+begin_src go <<Construct nodes in subtree, Pr. \ref{pr:nev}>>=
  out := []Node{}
  for _, taxon := range taxa {
	  parent := taxon
	  //<<Get node parent, Pr. \ref{pr:nev}>>
	  name := ""
	  cname := ""
	  //<<Get node names, Pr. \ref{pr:nev}>>
	  o := Node{Taxid: taxon, Parent: parent, Name: name,
		  CommonName: cname}
	  out = append(out, o)
  }
#+end_src
#+begin_export latex
We get the node's parent and skip the rest of the loop if we encounter
an error.
#+end_export
#+begin_src go <<Get node parent, Pr. \ref{pr:nev}>>=
  parent, err := neidb.Parent(taxon)
  util.Check(err)
  if err != nil {
	  continue
  }
#+end_src
#+begin_export latex
We get the node's scientific and common names and again skip to the
end of the loop if we encounter an error.
#+end_export
#+begin_src go <<Get node names, Pr. \ref{pr:nev}>>=
  name, err = neidb.Name(taxon)
  util.Check(err)
  if err != nil {
	  continue
  }
  cname, err = neidb.CommonName(taxon)
  util.Check(err)
  if err != nil {
	  continue
  }
#+end_src
#+begin_export latex
We register \ty{subtree}.
#+end_export
#+begin_src go <<Access \ty{tdb} functions, Pr. \ref{pr:nev}>>=
  http.HandleFunc("/subtree/", makeHandler(subtree))
#+end_src
#+begin_export latex
We also add \ty{subtree} to our list of services.
#+end_export
#+begin_src go <<Add services, Pr. \ref{pr:nev}>>=
  query = "?t=9606"
  service = Service{Name: "subtree",
	  Query: query}
  services = append(services, service)
#+end_src
#+begin_export latex
\subsection{\ty{Taxids}}
The function \ty{Taxids} takes as argument a taxon name and returns
the corresponding taxon IDs. We implement the query in the function
\ty{taxids} where we get the taxon name and store the corresponding
taxon IDs before we print the output.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:nev}>>=
  func taxids(w http.ResponseWriter, r *http.Request,
	  p *PageData) {
	  name := r.URL.Query().Get("t")
	  out := []Taxid{}
	  taxids, err := neidb.CommonTaxids(name, -1, 0)
	  util.Check(err)
	  for _, taxid := range taxids {
		  o := Taxid{taxid}
		  out = append(out, o)
	  }
	  //<<Print output, Pr. \ref{pr:nev}>>
  }
#+end_src
#+begin_export latex
We register \ty{taxids}.
#+end_export
#+begin_src go <<Access \ty{tdb} functions, Pr. \ref{pr:nev}>>=
  http.HandleFunc("/taxids/", makeHandler(taxids))
#+end_src
#+begin_export latex
We also add \ty{taxids} to the list of services.
#+end_export
#+begin_src go <<Add services, Pr. \ref{pr:nev}>>=
  query = "?t=Homo+sapiens"
  service = Service{Name: "taxids",
	  Query: query}
  services = append(services, service)
#+end_src

#+begin_export latex
\subsection{\ty{mrca}}
The service \ty{mrca} taks as argument a slice of taxon IDs and
returns their most recent comon ancestor. We implement the service in
the function \ty{mrca}, where we get the taxon IDs, caluclate their
most recent common ancestor, and print the output. If there is no most
recent common ancestor, we return taxid 0.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:nev}>>=
  func mrca(w http.ResponseWriter, r *http.Request, p *PageData) {
	  taxa := getTaxa(w, r)
	  out := Taxid{0}
	  if len(taxa) > 0 {
		  mrca, err := neidb.MRCA(taxa)
		  if err == nil {
			  out = Taxid{mrca}
		  }
	  }
	  //<<Print output, Pr. \ref{pr:nev}>>
  }
#+end_src
#+begin_export latex
We register \ty{mrca}.
#+end_export
#+begin_src go <<Access \ty{tdb} functions, Pr. \ref{pr:nev}>>=
  http.HandleFunc("/mrca/", makeHandler(mrca))
#+end_src
#+begin_export latex
We also add \ty{mrca} to our list of services.
#+end_export
#+begin_src go <<Add services, Pr. \ref{pr:nev}>>=
  query = "?t=9606,741158,63221"
  service = Service{Name: "mrca",
	  Query: query}
  services = append(services, service)
#+end_src
#+begin_export latex
\subsection{\ty{levels}}
The service \ty{levels} takes as argument a list of genome accessions
and returns their assembly levels. We store an assembly level in a
struct that wraps an accession/level pair.
#+end_export
#+begin_src go <<Types, Pr. \ref{pr:nev}>>=
  type Level struct {
	  Accession string `json:"accession"`
	  Level string `json:"level"`
  }
#+end_src
#+begin_export latex
In our implementation of \ty{level} we extract the accessions, get
their levels, and print the output.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:nev}>>=
  func levels(w http.ResponseWriter, r *http.Request,
	  p *PageData) {
	  //<<Extract accessions, Pr. \ref{pr:nev}>>
	  //<<Look up levels, Pr. \ref{pr:nev}>>
	  //<<Print output, Pr. \ref{pr:nev}>>
  }
#+end_src
#+begin_export latex
Accessions are passed as a comma-delimited string keyed by \ty{a}.
#+end_export
#+begin_src go <<Extract accessions, Pr. \ref{pr:nev}>>=
  str := r.URL.Query().Get("a")
  accessions := strings.Split(str, ",")
#+end_src
#+begin_export latex
We look up the level of each accession and store it.
#+end_export
#+begin_src go <<Look up levels, Pr. \ref{pr:nev}>>=
  out := []Level{}
  for _, accession := range accessions {
	  level, err := neidb.Level(accession)
	  if err == nil {
		  o := Level{Accession: accession, Level: level}
		  out = append(out, o)
	  }
  }
#+end_src
#+begin_export latex
We register \ty{levels}.
#+end_export
#+begin_src go <<Access \ty{tdb} functions, Pr. \ref{pr:nev}>>=
  http.HandleFunc("/levels/", makeHandler(levels))
#+end_src
#+begin_export latex
We also add \ty{levels} to our list of services.
#+end_export
#+begin_src go <<Add services, Pr. \ref{pr:nev}>>=
  query = "?a=GCF_000001405.40,GCA_000002115.2"
  service = Service{Name: "levels",
	  Query: query}
  services = append(services, service)
#+end_src
#+begin_export latex
\subsection{\ty{num\_genomes}}
The service \ty{num\_genomes} takes a taxon ID and returns the number
of genomes across all assembly levels. We store the genome counts in a
slice of type \ty{GenomeCount}, which holds the count for a given
level.
#+end_export
#+begin_src go <<Types, Pr. \ref{pr:nev}>>=
  type GenomeCount struct {
	  Level string `json:"level"`
	  Count int `json:"count"`
  }
#+end_src
#+begin_export latex
In the function \ty{num\_genomes} we get the taxon ID, get its
raw genome counts, and print the output.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:nev}>>=
  func num_genomes(w http.ResponseWriter, r *http.Request,
	  p *PageData) {
	  //<<Get taxid, Pr. \ref{pr:nev}>>
	  //<<Get raw genome counts, Pr. \ref{pr:nev}>>
	  //<<Print output, Pr. \ref{pr:nev}>>
  }
#+end_src
#+begin_export latex
We get the raw genome counts across all levels and store them.
#+end_export
#+begin_src go <<Get raw genome counts, Pr. \ref{pr:nev}>>=
  out := []GenomeCount{}
  for _, level := range tdb.AssemblyLevels() {
	  n, err := neidb.NumGenomes(taxid, level)
	  if err == nil {
		  o := GenomeCount{Count: n, Level: level}
		  out = append(out, o)
	  }
  }
#+end_src
#+begin_export latex
We register \ty{num\_genomes}.
#+end_export
#+begin_src go <<Access \ty{tdb} functions, Pr. \ref{pr:nev}>>=
  http.HandleFunc("/num_genomes/",
	  makeHandler(num_genomes))
#+end_src
#+begin_export latex
We also add \ty{num\_genomes} to our list of services with example
query \emph{Escherichia coli}, taxid 562.
#+end_export
#+begin_src go <<Add services, Pr. \ref{pr:nev}>>=
  query = "?t=562"
  service = Service{Name: "num_genomes",
	  Query: query}
  services = append(services, service)
#+end_src
#+begin_export latex
\subsection{\ty{num\_genomes\_rec}}
The service \ty{num\_genomes\_rec} takes a taxon ID as input and
returns the recursive number of genomes for all assembly levels. We
get the taxon ID, get the recursive genome counts for it, and print
the output.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:nev}>>=
  func num_genomes_rec(w http.ResponseWriter, r *http.Request,
	  p *PageData) {
	  //<<Get taxid, Pr. \ref{pr:nev}>>
	  //<<Get recursive genome counts, Pr. \ref{pr:nev}>>
	  //<<Print output, Pr. \ref{pr:nev}>>
  }
#+end_src
#+begin_export latex
Inside the function \ty{genome\_counts\_rec} we get the recursive
genome counts across the levels and store them.
#+end_export
#+begin_src go <<Get recursive genome counts, Pr. \ref{pr:nev}>>=
  out := []GenomeCount{}
  for _, level := range tdb.AssemblyLevels() {
	  n, err := neidb.NumGenomesRec(taxid, level)
	  if err == nil {
		  o := GenomeCount{Count: n, Level: level}
		  out = append(out, o)
	  }
  }
#+end_src
#+begin_export latex
We register \ty{num\_genomes\_rec}.
#+end_export
#+begin_src go <<Access \ty{tdb} functions, Pr. \ref{pr:nev}>>=
  http.HandleFunc("/num_genomes_rec/", makeHandler(num_genomes_rec))
#+end_src
#+begin_export latex
We also add \ty{num\_genomes\_rec} to our list of services and again
use \emph{Escherichia coli} as our example.
#+end_export
#+begin_src go <<Add services, Pr. \ref{pr:nev}>>=
  query = "?t=562"
  service = Service{Name: "num_genomes_rec",
	  Query: query}
  services = append(services, service)
#+end_src
#+begin_export latex
\subsection{\ty{taxa\_info}}
The service \ty{taxa\_info} takes as argument a string of
comma-delimited taxon IDs and returns the information available for
them. We get the taxon IDs and iterate over them to obtain and store
the corresponding information for each one. After the iteration we
print the output, which is stored as a slice of type \ty{TaxonInfo}.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:nev}>>=
  func taxa_info(w http.ResponseWriter, r *http.Request,
	  p *PageData) {
	  taxa := getTaxa(w, r)
	  out := []TaxonInfo{}
	  for _, taxon := range taxa {
		  //<<Get information, Pr. \ref{pr:nev}>>
		  //<<Store information, Pr. \ref{pr:nev}>>
	  }
	  //<<Print output, Pr. \ref{pr:nev}>>
  }
#+end_src
#+begin_export latex
\ty{TaxonInfo} is a structure that holds the IDs of the taxon and its
parent, wheter the taxon is a leaf in the taxonomy tree, the taxon's
name, its common name, its rank, its raw genome counts, and its
recursive genome counts.
#+end_export
#+begin_src go <<Types, Pr. \ref{pr:nev}>>=
  type TaxonInfo struct {
	  Taxid int `json:"taxid"`
	  Parent int `json:"parent"`
	  IsLeaf bool `json:"is_leaf"`
	  Name string `json:"name"`
	  CommonName string `json:"common_name"`
	  Rank string `json:"rank"`
	  RawCounts []GenomeCount `json:"raw_genome_counts"`
	  RecCounts []GenomeCount `json:"rec_genome_counts"`
  }
#+end_src
#+begin_export latex
We get the parent, determine whether the taxon is a leaf, its names,
rank, and the genome counts.
#+end_export
#+begin_src go <<Get information, Pr. \ref{pr:nev}>>=
  //<<Get parent, Pr. \ref{pr:nev}>>
  //<<Is the taxon a leaf? Pr. \ref{pr:nev}>>
  //<<Get names, Pr. \ref{pr:nev}>>
  //<<Get taxon rank, Pr. \ref{pr:nev}>>
  //<<Get genome counts, Pr. \ref{pr:nev}>>
#+end_src
#+begin_export latex
We look up the parent taxon and check the error.
#+end_export
#+begin_src go <<Get parent, Pr. \ref{pr:nev}>>=
  parent, err := neidb.Parent(taxon)
  util.Check(err)
#+end_src
#+begin_export latex
We determine whether the taxon is a leaf.
#+end_export
#+begin_src go <<Is the taxon a leaf? Pr. \ref{pr:nev}>>=
  isLeaf, err := neidb.IsLeaf(taxon)
  util.Check(err)
#+end_src
#+begin_export latex
We get the rank of the taxon.
#+end_export
#+begin_src go <<Get taxon rank, Pr. \ref{pr:nev}>>=
  rank, err := neidb.Rank(taxon)
  util.Check(err)
#+end_src
#+begin_export latex
We look up the taxon's scientific and common names with error
checking.
#+end_export
#+begin_src go <<Get names, Pr. \ref{pr:nev}>>=
  name, err := neidb.Name(taxon)
  util.Check(err)
  cname, err := neidb.CommonName(taxon)
  util.Check(err)
#+end_src
#+begin_export latex
We look up the raw and recursive genome counts across the assembly
levels.
#+end_export
#+begin_src go <<Get genome counts, Pr. \ref{pr:nev}>>=
  var raw, rec []GenomeCount
  for _, level := range tdb.AssemblyLevels() {
	  count, err := neidb.NumGenomes(taxon, level)
	  util.Check(err)
	  gc := GenomeCount{Count: count, Level: level}
	  raw = append(raw, gc)
	  count, err = neidb.NumGenomesRec(taxon, level)
	  util.Check(err)
	  gc = GenomeCount{Count: count, Level: level}
	  rec = append(rec, gc)
  }
#+end_src
#+begin_export latex
We store the taxon ID and the information we just looked up for our
focal taxon.
#+end_export
#+begin_src go <<Store information, Pr. \ref{pr:nev}>>=
  o := TaxonInfo {
	  Taxid: taxon,
	  Parent: parent,
	  IsLeaf: isLeaf,
	  Name: name,
	  CommonName: cname,
	  Rank: rank,
	  RawCounts: raw,
	  RecCounts: rec}
  out = append(out, o)
#+end_src
#+begin_export latex
We register \ty{taxon\_info}.
#+end_export
#+begin_src go <<Access \ty{tdb} functions, Pr. \ref{pr:nev}>>=
  http.HandleFunc("/taxa_info/", makeHandler(taxa_info))
#+end_src
#+begin_export latex
We also add \ty{taxa\_info} to our list of services and use
\emph{Escherichia coli} and \emph{Homo sapiens} as example.
#+end_export
#+begin_src go <<Add services, Pr. \ref{pr:nev}>>=
  query = "?t=562,9606"
  service = Service{Name: "taxa_info",
	  Query: query}
  services = append(services, service)
#+end_src
#+begin_export latex
\subsection{\ty{path}}
The service \ty{path} takes as input the taxon IDs of a start and an
end node in the taxonomy, where the end is closer to the root than the
start. It returns the array of taxon IDs that form the path from the
start to the end. If no such path exists, an empty array is returned.

We initialize the path calculation, add the start node, climb the rest
of the path, and print the output.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:nev}>>= 
  func path(w http.ResponseWriter, r *http.Request,
	  p *PageData) {
	  taxa := getTaxa(w, r)
	  //<<Initialize path calculation, Pr. \ref{pr:nev}>>
	  //<<Add start node, Pr. \ref{pr:nev}>>
	  //<<Climb path, Pr. \ref{pr:nev}>>
	  //<<Print output, Pr. \ref{pr:nev}>>
  }
#+end_src
#+begin_export latex
To initialize the path calculation, we declare the output slice and
check whether we obtained two taxon IDs from the user. If not, we
print the empty output and return.
#+end_export
#+begin_src go <<Initialize path calculation, Pr. \ref{pr:nev}>>=
  out := []Taxon{}
  if len(taxa) != 2 {
	  //<<Print output, Pr. \ref{pr:nev}>>
	  return
  }
  start := taxa[0]
  end := taxa[1]
#+end_src
#+begin_export latex
If the start node is root, we only add it if it is identical to the
end node. Otherwise, we again print the empty output and return.
#+end_export
#+begin_src go <<Add start node, Pr. \ref{pr:nev}>>=
  parent, err := neidb.Parent(start)
  util.Check(err)
  if parent == start && start != end {
	  //<<Print output, Pr. \ref{pr:nev}>>
	  return
  }
  name, err := neidb.Name(start)
  o := Taxon{Taxid: start, Parent: parent, Name: name}
  out = append(out, o)
#+end_src
#+begin_export latex
We climb the path until we reach its end or the root, whichever comes
first.
#+end_export
#+begin_src go <<Climb path, Pr. \ref{pr:nev}>>=
  for start != end {
	  parent, err := neidb.Parent(start)
	  util.Check(err)
	  //<<Has the path reached the root?, Pr. \ref{pr:nev}>>
	  start = parent
	  //<<Store new node on path, Pr. \ref{pr:nev}>>
  }
#+end_src
#+begin_export latex
If the path has reached the root, we empty the output slice and break
from climbing the tree.
#+end_export
#+begin_src go <<Has the path reached the root?, Pr. \ref{pr:nev}>>=
  if start == parent {
	  out = out[:0]
	  break
  }
#+end_src
#+begin_export latex
We construct and store the new node on the path.
#+end_export
#+begin_src go <<Store new node on path, Pr. \ref{pr:nev}>>=
  name, err := neidb.Name(start)
  util.Check(err)
  cname, err := neidb.CommonName(start)
  util.Check(err)
  parent, err = neidb.Parent(start)
  util.Check(err)
  o := Taxon{Taxid: start, Parent: parent, Name: name,
	  CommonName: cname}
  out = append(out, o)
#+end_src
#+begin_export latex
We register the service \ty{path}.
#+end_export
#+begin_src go <<Access \ty{tdb} functions, Pr. \ref{pr:nev}>>=
  http.HandleFunc("/path/", makeHandler(path))
#+end_src
#+begin_export latex
We also add \ty{path} to our list of services and use the path between
\emph{Homo sapiens} and \emph{Mammalia} as our example.
#+end_export
#+begin_src go <<Add services, Pr. \ref{pr:nev}>>=
  query = "?t=9606,40674"
  service = Service{Name: "path",
	  Query: query}
  services = append(services, service)
#+end_src
#+begin_export latex
\section{Start Server}
We have built the server, now we can start it. If the user supplied a
pair of encryption keys, we start it as an HTTPS server, otherwise its
an HTTP server.
#+end_export
#+begin_src go <<Start server, Pr. \ref{pr:nev}>>=
  host := *flagO + ":" + *flagP
  if *flagC != "" && *flagK != "" {
	  log.Fatal(http.ListenAndServeTLS(host, *flagC,
		  ,*flagK, nil))
  } else {
	  log.Fatal(http.ListenAndServe(host, nil))
  }
#+end_src
#+begin_export latex
We are done writing \ty{never}, time to test it.
#+end_export
