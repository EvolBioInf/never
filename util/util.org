#+begin_export latex
! Package \ty{util} provides auxiliary functions for the \ty{never}
! package.

Our outline of \ty{util} has hooks for imports, variables, and
functions.  \bpa{util}{pa:uti}
#+end_export
#+begin_src go <<util.go>>=
  package util

  import (
	  //<<Imports, Pa. \ref{pa:uti}>>
  )
  //<<Variables, Pa. \ref{pa:uti}>>
  //<<Functions, Pa. \ref{pa:uti}>>
#+end_src
#+begin_export latex
  \epa
  \section{\ty{Check}}
  ! \ty{Check} takes an error as argument and logs a fatal error if the
  ! error isn't \ty{nil}.
#+end_export
#+begin_src go <<Functions, Pa. \ref{pa:uti}>>=
  func Check(err error) {
	  if err != nil {
		  log.Fatal(err)
	  }
  }
#+end_src
#+begin_export latex
We import \ty{log}.
#+end_export
#+begin_src go <<Imports, Pa. \ref{pa:uti}>>=
  "log"
#+end_src
#+begin_export latex
\section{\ty{CheckHTTP}}
! \ty{CheckHTTP} takes as arguments a HTTP respose writer and an
! eror. It logs a HTTP error if the input error it isn't \ty{nil}.
#+end_export
#+begin_src go <<Functions, Pa. \ref{pa:uti}>>=
  func CheckHTTP(w http.ResponseWriter, err error) {
	  if err != nil {
		  http.Error(w, err.Error(),
			  http.StatusInternalServerError)
	  }
  }
#+end_src
#+begin_export latex
We import \ty{http}.
#+end_export
#+begin_src go <<Imports, Pa. \ref{pa:uti}>>=
  "net/http"
#+end_src
#+begin_export latex
\section{\ty{PrepLog}}
! \ty{PrepLog} takes as argument the program name and uses it as
! prefix for the log message.

We also store the program name in the variable \ty{program} to make it
accessible from elsewhere in the package.
#+end_export
#+begin_src go <<Functions, Pa. \ref{pa:uti}>>=
  func PrepLog(progName string) {
	  log.SetPrefix(progName + ": ")
	  program = progName
  }
#+end_src
#+begin_export latex
We declare the variable \ty{program}.
#+end_export
#+begin_src go <<Variables, Pa. \ref{pa:uti}>>=
  var program string
#+end_src
#+begin_export latex
  \section{\ty{PrintInfo}}
  ! \ty{PrintInfo} prints information about the version, the
  ! author(s), and the license of \ty{never}.

  We set the author, email, and license.
#+end_export
#+begin_src go <<Functions, Pa. \ref{pa:uti}>>=
  func PrintInfo() {
	    authors := "Bernhard Haubold"
	    email := "haubold@evolbio.mpg.de"
	    license := "Gnu General Public License, " +
		    "https://www.gnu.org/licenses/gpl.html"
	    clio.PrintInfo(program, version, date,
		    authors, email, license)
	    os.Exit(0)
  }
#+end_src
#+begin_export latex
The date and the version are injected at compile time, so like
\ty{program} we declare them as package variables.
#+end_export
#+begin_src go <<Variables, Pa. \ref{pa:uti}>>=
  var date, version string
#+end_src
#+begin_export latex
  We import \ty{clio} and \ty{os}
#+end_export
#+begin_src go <<Imports, Pa. \ref{pa:uti}>>=
  "github.com/evolbioinf/clio"
  "os"
#+end_src

